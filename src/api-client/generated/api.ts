/* tslint:disable */
/* eslint-disable */
/**
 * dBildungs IAM
 * The dBildungs IAM server API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreateOrganisationBodyParams
 */
export interface CreateOrganisationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'administriertVon'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'zugehoerigZu'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'kennung': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'namensergaenzung': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'kuerzel': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'typ': CreateOrganisationBodyParamsTypEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'traegerschaft'?: CreateOrganisationBodyParamsTraegerschaftEnum;
}

export const CreateOrganisationBodyParamsTypEnum = {
    Schule: 'SCHULE',
    Anbieter: 'ANBIETER',
    SonstigeOrganisationEinrichtung: 'SONSTIGE ORGANISATION / EINRICHTUNG',
    Unbestaetigt: 'UNBESTAETIGT'
} as const;

export type CreateOrganisationBodyParamsTypEnum = typeof CreateOrganisationBodyParamsTypEnum[keyof typeof CreateOrganisationBodyParamsTypEnum];
export const CreateOrganisationBodyParamsTraegerschaftEnum = {
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06'
} as const;

export type CreateOrganisationBodyParamsTraegerschaftEnum = typeof CreateOrganisationBodyParamsTraegerschaftEnum[keyof typeof CreateOrganisationBodyParamsTraegerschaftEnum];

/**
 * 
 * @export
 * @interface CreatePersonBodyParams
 */
export interface CreatePersonBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'stammorganisation'?: string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof CreatePersonBodyParams
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof CreatePersonBodyParams
     */
    'geburt'?: PersonBirthParams;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'geschlecht'?: CreatePersonBodyParamsGeschlechtEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'lokalisierung'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'vertrauensstufe'?: CreatePersonBodyParamsVertrauensstufeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePersonBodyParams
     */
    'auskunftssperre'?: boolean;
}

export const CreatePersonBodyParamsGeschlechtEnum = {
    M: 'm',
    W: 'w',
    D: 'd',
    X: 'x'
} as const;

export type CreatePersonBodyParamsGeschlechtEnum = typeof CreatePersonBodyParamsGeschlechtEnum[keyof typeof CreatePersonBodyParamsGeschlechtEnum];
export const CreatePersonBodyParamsVertrauensstufeEnum = {
    Kein: 'KEIN',
    Unbe: 'UNBE',
    Teil: 'TEIL',
    Voll: 'VOLL'
} as const;

export type CreatePersonBodyParamsVertrauensstufeEnum = typeof CreatePersonBodyParamsVertrauensstufeEnum[keyof typeof CreatePersonBodyParamsVertrauensstufeEnum];

/**
 * 
 * @export
 * @interface CreatePersonenkontextBodyParams
 */
export interface CreatePersonenkontextBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonenkontextBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonenkontextBodyParams
     */
    'rolle': CreatePersonenkontextBodyParamsRolleEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonenkontextBodyParams
     */
    'personenstatus'?: CreatePersonenkontextBodyParamsPersonenstatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonenkontextBodyParams
     */
    'jahrgangsstufe'?: CreatePersonenkontextBodyParamsJahrgangsstufeEnum;
}

export const CreatePersonenkontextBodyParamsRolleEnum = {
    Lern: 'LERN',
    Lehr: 'LEHR',
    Extern: 'EXTERN',
    Orgadmin: 'ORGADMIN',
    Leit: 'LEIT',
    Sysadmin: 'SYSADMIN'
} as const;

export type CreatePersonenkontextBodyParamsRolleEnum = typeof CreatePersonenkontextBodyParamsRolleEnum[keyof typeof CreatePersonenkontextBodyParamsRolleEnum];
export const CreatePersonenkontextBodyParamsPersonenstatusEnum = {
    Aktiv: 'AKTIV'
} as const;

export type CreatePersonenkontextBodyParamsPersonenstatusEnum = typeof CreatePersonenkontextBodyParamsPersonenstatusEnum[keyof typeof CreatePersonenkontextBodyParamsPersonenstatusEnum];
export const CreatePersonenkontextBodyParamsJahrgangsstufeEnum = {
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10'
} as const;

export type CreatePersonenkontextBodyParamsJahrgangsstufeEnum = typeof CreatePersonenkontextBodyParamsJahrgangsstufeEnum[keyof typeof CreatePersonenkontextBodyParamsJahrgangsstufeEnum];

/**
 * 
 * @export
 * @interface CreateRolleBodyParams
 */
export interface CreateRolleBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreateRolleBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRolleBodyParams
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRolleBodyParams
     */
    'rollenart': CreateRolleBodyParamsRollenartEnum;
    /**
     * 
     * @type {Set<string>}
     * @memberof CreateRolleBodyParams
     */
    'merkmale': Set<CreateRolleBodyParamsMerkmaleEnum>;
}

export const CreateRolleBodyParamsRollenartEnum = {
    Lern: 'LERN',
    Lehr: 'LEHR',
    Extern: 'EXTERN',
    Orgadmin: 'ORGADMIN',
    Leit: 'LEIT',
    Sysadmin: 'SYSADMIN'
} as const;

export type CreateRolleBodyParamsRollenartEnum = typeof CreateRolleBodyParamsRollenartEnum[keyof typeof CreateRolleBodyParamsRollenartEnum];
export const CreateRolleBodyParamsMerkmaleEnum = {
    BefristungPflicht: 'BEFRISTUNG_PFLICHT',
    KopersPflicht: 'KOPERS_PFLICHT'
} as const;

export type CreateRolleBodyParamsMerkmaleEnum = typeof CreateRolleBodyParamsMerkmaleEnum[keyof typeof CreateRolleBodyParamsMerkmaleEnum];

/**
 * 
 * @export
 * @interface LoeschungResponse
 */
export interface LoeschungResponse {
    /**
     * 
     * @type {string}
     * @memberof LoeschungResponse
     */
    'zeitpunkt': string;
}
/**
 * 
 * @export
 * @interface OrganisationByIdBodyParams
 */
export interface OrganisationByIdBodyParams {
    /**
     * The id of an organization
     * @type {string}
     * @memberof OrganisationByIdBodyParams
     */
    'organisationId': string;
}
/**
 * 
 * @export
 * @interface OrganisationResponse
 */
export interface OrganisationResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'kennung': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'namensergaenzung': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'kuerzel': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'typ': OrganisationResponseTypEnum;
}

export const OrganisationResponseTypEnum = {
    Schule: 'SCHULE',
    Anbieter: 'ANBIETER',
    SonstigeOrganisationEinrichtung: 'SONSTIGE ORGANISATION / EINRICHTUNG',
    Unbestaetigt: 'UNBESTAETIGT'
} as const;

export type OrganisationResponseTypEnum = typeof OrganisationResponseTypEnum[keyof typeof OrganisationResponseTypEnum];

/**
 * 
 * @export
 * @interface PersonBirthParams
 */
export interface PersonBirthParams {
    /**
     * 
     * @type {string}
     * @memberof PersonBirthParams
     */
    'datum'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonBirthParams
     */
    'geburtsort'?: string;
}
/**
 * 
 * @export
 * @interface PersonControllerFindPersonenkontexte200Response
 */
export interface PersonControllerFindPersonenkontexte200Response {
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'items': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonControllerFindPersonenkontexte200ResponseAllOf
 */
export interface PersonControllerFindPersonenkontexte200ResponseAllOf {
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonControllerFindPersonenkontexte200ResponseAllOf
     */
    'items': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonFrontendControllerFindPersons200Response
 */
export interface PersonFrontendControllerFindPersons200Response {
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<PersonendatensatzResponse>}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'items': Array<PersonendatensatzResponse>;
}
/**
 * 
 * @export
 * @interface PersonFrontendControllerFindPersons200ResponseAllOf
 */
export interface PersonFrontendControllerFindPersons200ResponseAllOf {
    /**
     * 
     * @type {Array<PersonendatensatzResponse>}
     * @memberof PersonFrontendControllerFindPersons200ResponseAllOf
     */
    'items': Array<PersonendatensatzResponse>;
}
/**
 * 
 * @export
 * @interface PersonNameParams
 */
export interface PersonNameParams {
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'familienname': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'initialenfamilienname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'initialenvorname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'rufname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'titel'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'anrede'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'namenssuffix'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'namenspraefix'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'sortierindex'?: string;
}
/**
 * 
 * @export
 * @interface PersonResponse
 */
export interface PersonResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'referrer': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'mandant': string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof PersonResponse
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof PersonResponse
     */
    'geburt': PersonBirthParams;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'stammorganisation': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'geschlecht': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'lokalisierung': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'vertrauensstufe': PersonResponseVertrauensstufeEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'revision': string;
    /**
     * Initiales Benutzerpasswort, muss nach der ersten Anmeldung geändert werden
     * @type {string}
     * @memberof PersonResponse
     */
    'startpasswort': string;
}

export const PersonResponseVertrauensstufeEnum = {
    Kein: 'KEIN',
    Unbe: 'UNBE',
    Teil: 'TEIL',
    Voll: 'VOLL'
} as const;

export type PersonResponseVertrauensstufeEnum = typeof PersonResponseVertrauensstufeEnum[keyof typeof PersonResponseVertrauensstufeEnum];

/**
 * 
 * @export
 * @interface PersonendatensatzResponse
 */
export interface PersonendatensatzResponse {
    /**
     * 
     * @type {PersonResponse}
     * @memberof PersonendatensatzResponse
     */
    'person': PersonResponse;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonendatensatzResponse
     */
    'personenkontexte': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonenkontextResponse
 */
export interface PersonenkontextResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'referrer': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'mandant': string;
    /**
     * 
     * @type {object}
     * @memberof PersonenkontextResponse
     */
    'organisation': object;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'rolle': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'personenstatus': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'jahrgangsstufe': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'sichtfreigabe': string;
    /**
     * 
     * @type {LoeschungResponse}
     * @memberof PersonenkontextResponse
     */
    'loeschung': LoeschungResponse;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'revision': string;
}
/**
 * 
 * @export
 * @interface RawPagedResponse
 */
export interface RawPagedResponse {
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'limit': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RawPagedResponse
     */
    'items': Array<string>;
}
/**
 * 
 * @export
 * @interface RolleResponse
 */
export interface RolleResponse {
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'rollenart': RolleResponseRollenartEnum;
    /**
     * 
     * @type {Set<string>}
     * @memberof RolleResponse
     */
    'merkmale': Set<RolleResponseMerkmaleEnum>;
}

export const RolleResponseRollenartEnum = {
    Lern: 'LERN',
    Lehr: 'LEHR',
    Extern: 'EXTERN',
    Orgadmin: 'ORGADMIN',
    Leit: 'LEIT',
    Sysadmin: 'SYSADMIN'
} as const;

export type RolleResponseRollenartEnum = typeof RolleResponseRollenartEnum[keyof typeof RolleResponseRollenartEnum];
export const RolleResponseMerkmaleEnum = {
    BefristungPflicht: 'BEFRISTUNG_PFLICHT',
    KopersPflicht: 'KOPERS_PFLICHT'
} as const;

export type RolleResponseMerkmaleEnum = typeof RolleResponseMerkmaleEnum[keyof typeof RolleResponseMerkmaleEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceProviderKategorie = {
    Email: 'EMAIL',
    Unterricht: 'UNTERRICHT',
    Verwaltung: 'VERWALTUNG',
    Hinweise: 'HINWEISE',
    Angebote: 'ANGEBOTE'
} as const;

export type ServiceProviderKategorie = typeof ServiceProviderKategorie[keyof typeof ServiceProviderKategorie];


/**
 * 
 * @export
 * @interface ServiceProviderResponse
 */
export interface ServiceProviderResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'url': string;
    /**
     * 
     * @type {ServiceProviderKategorie}
     * @memberof ServiceProviderResponse
     */
    'kategorie': ServiceProviderKategorie;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderResponse
     */
    'hasLogo': boolean;
}


/**
 * 
 * @export
 * @interface UpdateOrganisationBodyParams
 */
export interface UpdateOrganisationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'administriertVon'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'zugehoerigZu'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'kennung': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'namensergaenzung': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'kuerzel': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'typ': UpdateOrganisationBodyParamsTypEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'traegerschaft'?: UpdateOrganisationBodyParamsTraegerschaftEnum;
}

export const UpdateOrganisationBodyParamsTypEnum = {
    Schule: 'SCHULE',
    Anbieter: 'ANBIETER',
    SonstigeOrganisationEinrichtung: 'SONSTIGE ORGANISATION / EINRICHTUNG',
    Unbestaetigt: 'UNBESTAETIGT'
} as const;

export type UpdateOrganisationBodyParamsTypEnum = typeof UpdateOrganisationBodyParamsTypEnum[keyof typeof UpdateOrganisationBodyParamsTypEnum];
export const UpdateOrganisationBodyParamsTraegerschaftEnum = {
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06'
} as const;

export type UpdateOrganisationBodyParamsTraegerschaftEnum = typeof UpdateOrganisationBodyParamsTraegerschaftEnum[keyof typeof UpdateOrganisationBodyParamsTraegerschaftEnum];

/**
 * 
 * @export
 * @interface UpdatePersonBodyParams
 */
export interface UpdatePersonBodyParams {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'stammorganisation'?: string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof UpdatePersonBodyParams
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof UpdatePersonBodyParams
     */
    'geburt'?: PersonBirthParams;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'geschlecht'?: UpdatePersonBodyParamsGeschlechtEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'lokalisierung'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'vertrauensstufe'?: UpdatePersonBodyParamsVertrauensstufeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePersonBodyParams
     */
    'auskunftssperre'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'revision': string;
}

export const UpdatePersonBodyParamsGeschlechtEnum = {
    M: 'm',
    W: 'w',
    D: 'd',
    X: 'x'
} as const;

export type UpdatePersonBodyParamsGeschlechtEnum = typeof UpdatePersonBodyParamsGeschlechtEnum[keyof typeof UpdatePersonBodyParamsGeschlechtEnum];
export const UpdatePersonBodyParamsVertrauensstufeEnum = {
    Kein: 'KEIN',
    Unbe: 'UNBE',
    Teil: 'TEIL',
    Voll: 'VOLL'
} as const;

export type UpdatePersonBodyParamsVertrauensstufeEnum = typeof UpdatePersonBodyParamsVertrauensstufeEnum[keyof typeof UpdatePersonBodyParamsVertrauensstufeEnum];

/**
 * 
 * @export
 * @interface UserinfoResponse
 */
export interface UserinfoResponse {
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'sub': string;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'given_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'family_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'middle_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'preferred_username': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'profile': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'picture': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'website': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'email': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserinfoResponse
     */
    'email_verified': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'zoneinfo': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'locale': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'phone_number': string | null;
    /**
     * 
     * @type {number}
     * @memberof UserinfoResponse
     */
    'updated_at': number | null;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logininfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogin: async (redirectUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserinfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerLogin(redirectUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerInfo(options?: any): AxiosPromise<UserinfoResponse> {
            return localVarFp.authenticationControllerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogin(redirectUrl?: string, options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerLogin(redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogout(options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 
     * @summary Info about logged in user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerInfo(options?: AxiosRequestConfig): AxiosPromise<UserinfoResponse>;

    /**
     * 
     * @summary Used to start OIDC authentication.
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Used to log out the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerLogout(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 
     * @summary Info about logged in user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerInfo(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to start OIDC authentication.
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerLogin(redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to log out the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganisationenApi - axios parameter creator
 * @export
 */
export const OrganisationenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddAdministrierteOrganisation: async (organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerAddAdministrierteOrganisation', 'organisationId', organisationId)
            // verify required parameter 'organisationByIdBodyParams' is not null or undefined
            assertParamExists('organisationControllerAddAdministrierteOrganisation', 'organisationByIdBodyParams', organisationByIdBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}/administriert`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationByIdBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddZugehoerigeOrganisation: async (organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerAddZugehoerigeOrganisation', 'organisationId', organisationId)
            // verify required parameter 'organisationByIdBodyParams' is not null or undefined
            assertParamExists('organisationControllerAddZugehoerigeOrganisation', 'organisationByIdBodyParams', organisationByIdBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}/zugehoerig`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationByIdBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerCreateOrganisation: async (createOrganisationBodyParams: CreateOrganisationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganisationBodyParams' is not null or undefined
            assertParamExists('organisationControllerCreateOrganisation', 'createOrganisationBodyParams', createOrganisationBodyParams)
            const localVarPath = `/api/organisationen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganisationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganisationById: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerFindOrganisationById', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT'} [typ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganizations: async (offset?: number, limit?: number, kennung?: string, name?: string, typ?: 'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organisationen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (kennung !== undefined) {
                localVarQueryParameter['kennung'] = kennung;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (typ !== undefined) {
                localVarQueryParameter['typ'] = typ;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetAdministrierteOrganisationen: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerGetAdministrierteOrganisationen', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}/administriert`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootOrganisation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organisationen/root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetZugehoerigeOrganisationen: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerGetZugehoerigeOrganisationen', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}/zugehoerig`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisation: async (organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisation', 'organisationId', organisationId)
            // verify required parameter 'updateOrganisationBodyParams' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisation', 'updateOrganisationBodyParams', updateOrganisationBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganisationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationenApi - functional programming interface
 * @export
 */
export const OrganisationenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerCreateOrganisation(createOrganisationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerFindOrganisationById(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT'} [typ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, typ?: 'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerFindOrganizations(offset, limit, kennung, name, typ, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetAdministrierteOrganisationen(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetRootOrganisation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetRootOrganisation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetZugehoerigeOrganisationen(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganisationenApi - factory interface
 * @export
 */
export const OrganisationenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationenApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerCreateOrganisation(createOrganisationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganisationById(organisationId: string, options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerFindOrganisationById(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT'} [typ] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, typ?: 'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT', options?: any): AxiosPromise<Array<OrganisationResponse>> {
            return localVarFp.organisationControllerFindOrganizations(offset, limit, kennung, name, typ, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: any): AxiosPromise<Array<OrganisationResponse>> {
            return localVarFp.organisationControllerGetAdministrierteOrganisationen(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootOrganisation(options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerGetRootOrganisation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: any): AxiosPromise<Array<OrganisationResponse>> {
            return localVarFp.organisationControllerGetZugehoerigeOrganisationen(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationenApi - interface
 * @export
 * @interface OrganisationenApi
 */
export interface OrganisationenApiInterface {
    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [kennung] 
     * @param {string} [name] 
     * @param {'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT'} [typ] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, typ?: 'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT', options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponse>>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponse>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetRootOrganisation(options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponse>>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

}

/**
 * OrganisationenApi - object-oriented interface
 * @export
 * @class OrganisationenApi
 * @extends {BaseAPI}
 */
export class OrganisationenApi extends BaseAPI implements OrganisationenApiInterface {
    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerCreateOrganisation(createOrganisationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerFindOrganisationById(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [kennung] 
     * @param {string} [name] 
     * @param {'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT'} [typ] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, typ?: 'SCHULE' | 'ANBIETER' | 'SONSTIGE ORGANISATION / EINRICHTUNG' | 'UNBESTAETIGT', options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerFindOrganizations(offset, limit, kennung, name, typ, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetAdministrierteOrganisationen(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetRootOrganisation(options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetRootOrganisation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetZugehoerigeOrganisationen(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenApi - axios parameter creator
 * @export
 */
export const PersonenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePersonBodyParams} createPersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePerson: async (createPersonBodyParams: CreatePersonBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonBodyParams' is not null or undefined
            assertParamExists('personControllerCreatePerson', 'createPersonBodyParams', createPersonBodyParams)
            const localVarPath = `/api/personen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePersonenkontext: async (personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerCreatePersonenkontext', 'personId', personId)
            // verify required parameter 'createPersonenkontextBodyParams' is not null or undefined
            assertParamExists('personControllerCreatePersonenkontext', 'createPersonenkontextBodyParams', createPersonenkontextBodyParams)
            const localVarPath = `/api/personen/{personId}/personenkontexte`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonenkontextBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonById: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerFindPersonById', 'personId', personId)
            const localVarPath = `/api/personen/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN'} [rolle] 
         * @param {'AKTIV'} [personenstatus] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonenkontexte: async (personId: string, offset?: number, limit?: number, referrer?: string, rolle?: 'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN', personenstatus?: 'AKTIV', sichtfreigabe?: 'ja' | 'nein', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerFindPersonenkontexte', 'personId', personId)
            const localVarPath = `/api/personen/{personId}/personenkontexte`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (rolle !== undefined) {
                localVarQueryParameter['rolle'] = rolle;
            }

            if (personenstatus !== undefined) {
                localVarQueryParameter['personenstatus'] = personenstatus;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersons: async (offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (familienname !== undefined) {
                localVarQueryParameter['familienname'] = familienname;
            }

            if (vorname !== undefined) {
                localVarQueryParameter['vorname'] = vorname;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerResetPasswordByPersonId: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerResetPasswordByPersonId', 'personId', personId)
            const localVarPath = `/api/personen/{personId}/password`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePerson: async (personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerUpdatePerson', 'personId', personId)
            // verify required parameter 'updatePersonBodyParams' is not null or undefined
            assertParamExists('personControllerUpdatePerson', 'updatePersonBodyParams', updatePersonBodyParams)
            const localVarPath = `/api/personen/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenApi - functional programming interface
 * @export
 */
export const PersonenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePersonBodyParams} createPersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerCreatePerson(createPersonBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerCreatePersonenkontext(personId, createPersonenkontextBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersonById(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersonById(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN'} [rolle] 
         * @param {'AKTIV'} [personenstatus] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: 'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN', personenstatus?: 'AKTIV', sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonControllerFindPersonenkontexte200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersonenkontexte(personId, offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonendatensatzResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerResetPasswordByPersonId(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerUpdatePerson(personId, updatePersonBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenApi - factory interface
 * @export
 */
export const PersonenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePersonBodyParams} createPersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerCreatePerson(createPersonBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.personControllerCreatePersonenkontext(personId, createPersonenkontextBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonById(personId: string, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerFindPersonById(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN'} [rolle] 
         * @param {'AKTIV'} [personenstatus] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: 'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN', personenstatus?: 'AKTIV', sichtfreigabe?: 'ja' | 'nein', options?: any): AxiosPromise<PersonControllerFindPersonenkontexte200Response> {
            return localVarFp.personControllerFindPersonenkontexte(personId, offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: any): AxiosPromise<Array<PersonendatensatzResponse>> {
            return localVarFp.personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerResetPasswordByPersonId(personId: string, options?: any): AxiosPromise<string> {
            return localVarFp.personControllerResetPasswordByPersonId(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerUpdatePerson(personId, updatePersonBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenApi - interface
 * @export
 * @interface PersonenApi
 */
export interface PersonenApiInterface {
    /**
     * 
     * @param {CreatePersonBodyParams} createPersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersonById(personId: string, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN'} [rolle] 
     * @param {'AKTIV'} [personenstatus] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: 'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN', personenstatus?: 'AKTIV', sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig): AxiosPromise<PersonControllerFindPersonenkontexte200Response>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig): AxiosPromise<Array<PersonendatensatzResponse>>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {UpdatePersonBodyParams} updatePersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

}

/**
 * PersonenApi - object-oriented interface
 * @export
 * @class PersonenApi
 * @extends {BaseAPI}
 */
export class PersonenApi extends BaseAPI implements PersonenApiInterface {
    /**
     * 
     * @param {CreatePersonBodyParams} createPersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerCreatePerson(createPersonBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerCreatePersonenkontext(personId, createPersonenkontextBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersonById(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersonById(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN'} [rolle] 
     * @param {'AKTIV'} [personenstatus] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: 'LERN' | 'LEHR' | 'EXTERN' | 'ORGADMIN' | 'LEIT' | 'SYSADMIN', personenstatus?: 'AKTIV', sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersonenkontexte(personId, offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerResetPasswordByPersonId(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {UpdatePersonBodyParams} updatePersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerUpdatePerson(personId, updatePersonBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenFrontendApi - axios parameter creator
 * @export
 */
export const PersonenFrontendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personFrontendControllerFindPersons: async (offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personen-frontend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (familienname !== undefined) {
                localVarQueryParameter['familienname'] = familienname;
            }

            if (vorname !== undefined) {
                localVarQueryParameter['vorname'] = vorname;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenFrontendApi - functional programming interface
 * @export
 */
export const PersonenFrontendApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenFrontendApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonFrontendControllerFindPersons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenFrontendApi - factory interface
 * @export
 */
export const PersonenFrontendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenFrontendApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: any): AxiosPromise<PersonFrontendControllerFindPersons200Response> {
            return localVarFp.personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenFrontendApi - interface
 * @export
 * @interface PersonenFrontendApi
 */
export interface PersonenFrontendApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenFrontendApiInterface
     */
    personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig): AxiosPromise<PersonFrontendControllerFindPersons200Response>;

}

/**
 * PersonenFrontendApi - object-oriented interface
 * @export
 * @class PersonenFrontendApi
 * @extends {BaseAPI}
 */
export class PersonenFrontendApi extends BaseAPI implements PersonenFrontendApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenFrontendApi
     */
    public personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', options?: AxiosRequestConfig) {
        return PersonenFrontendApiFp(this.configuration).personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProviderApi - axios parameter creator
 * @export
 */
export const ProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProviderLogo: async (angebotId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'angebotId' is not null or undefined
            assertParamExists('providerControllerGetServiceProviderLogo', 'angebotId', angebotId)
            const localVarPath = `/api/provider/{angebotId}/logo`
                .replace(`{${"angebotId"}}`, encodeURIComponent(String(angebotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProvidersByPersonId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetServiceProviderLogo(angebotId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetServiceProvidersByPersonId(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceProviderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetServiceProvidersByPersonId(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderApiFp(configuration)
    return {
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProviderLogo(angebotId: string, options?: any): AxiosPromise<any> {
            return localVarFp.providerControllerGetServiceProviderLogo(angebotId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProvidersByPersonId(options?: any): AxiosPromise<Array<ServiceProviderResponse>> {
            return localVarFp.providerControllerGetServiceProvidersByPersonId(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderApi - interface
 * @export
 * @interface ProviderApi
 */
export interface ProviderApiInterface {
    /**
     * 
     * @param {string} angebotId The id of the service provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetServiceProvidersByPersonId(options?: AxiosRequestConfig): AxiosPromise<Array<ServiceProviderResponse>>;

}

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI implements ProviderApiInterface {
    /**
     * 
     * @param {string} angebotId The id of the service provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetServiceProviderLogo(angebotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetServiceProvidersByPersonId(options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetServiceProvidersByPersonId(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolleApi - axios parameter creator
 * @export
 */
export const RolleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerCreateRolle: async (createRolleBodyParams: CreateRolleBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRolleBodyParams' is not null or undefined
            assertParamExists('rolleControllerCreateRolle', 'createRolleBodyParams', createRolleBodyParams)
            const localVarPath = `/api/rolle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRolleBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rollen.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRollen: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rolle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolleApi - functional programming interface
 * @export
 */
export const RolleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerCreateRolle(createRolleBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rollen.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerFindRollen(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RolleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerFindRollen(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolleApi - factory interface
 * @export
 */
export const RolleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolleApiFp(configuration)
    return {
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: any): AxiosPromise<RolleResponse> {
            return localVarFp.rolleControllerCreateRolle(createRolleBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rollen.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRollen(options?: any): AxiosPromise<Array<RolleResponse>> {
            return localVarFp.rolleControllerFindRollen(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolleApi - interface
 * @export
 * @interface RolleApi
 */
export interface RolleApiInterface {
    /**
     * Create a new rolle.
     * @summary 
     * @param {CreateRolleBodyParams} createRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig): AxiosPromise<RolleResponse>;

    /**
     * List all rollen.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerFindRollen(options?: AxiosRequestConfig): AxiosPromise<Array<RolleResponse>>;

}

/**
 * RolleApi - object-oriented interface
 * @export
 * @class RolleApi
 * @extends {BaseAPI}
 */
export class RolleApi extends BaseAPI implements RolleApiInterface {
    /**
     * Create a new rolle.
     * @summary 
     * @param {CreateRolleBodyParams} createRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerCreateRolle(createRolleBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rollen.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerFindRollen(options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerFindRollen(options).then((request) => request(this.axios, this.basePath));
    }
}



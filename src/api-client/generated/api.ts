/* tslint:disable */
/* eslint-disable */
/**
 * dBildungs IAM
 * The dBildungs IAM server API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddSystemrechtBodyParams
 */
export interface AddSystemrechtBodyParams {
    /**
     * 
     * @type {RollenSystemRecht}
     * @memberof AddSystemrechtBodyParams
     */
    'systemRecht': RollenSystemRecht;
}


/**
 * 
 * @export
 * @interface AssignHardwareTokenBodyParams
 */
export interface AssignHardwareTokenBodyParams {
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenBodyParams
     */
    'serial': string;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenBodyParams
     */
    'otp': string;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenBodyParams
     */
    'referrer': string;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenBodyParams
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface AssignHardwareTokenResponse
 */
export interface AssignHardwareTokenResponse {
    /**
     * 
     * @type {number}
     * @memberof AssignHardwareTokenResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenResponse
     */
    'jsonrpc': string;
    /**
     * 
     * @type {number}
     * @memberof AssignHardwareTokenResponse
     */
    'time': number;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenResponse
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenResponse
     */
    'versionnumber': string;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenResponse
     */
    'signature': string;
    /**
     * 
     * @type {string}
     * @memberof AssignHardwareTokenResponse
     */
    'dialogText': string;
}
/**
 * 
 * @export
 * @interface CreateOrganisationBodyParams
 */
export interface CreateOrganisationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'administriertVon'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'zugehoerigZu'?: string;
    /**
     * Required, if `typ` is equal to `SCHULE`
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'kennung'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'namensergaenzung'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'kuerzel'?: string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof CreateOrganisationBodyParams
     */
    'typ': OrganisationsTyp;
    /**
     * 
     * @type {TraegerschaftTyp}
     * @memberof CreateOrganisationBodyParams
     */
    'traegerschaft'?: TraegerschaftTyp;
}


/**
 * 
 * @export
 * @interface CreatePersonMigrationBodyParams
 */
export interface CreatePersonMigrationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonMigrationBodyParams
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonMigrationBodyParams
     */
    'familienname': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonMigrationBodyParams
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonMigrationBodyParams
     */
    'hashedPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonMigrationBodyParams
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonMigrationBodyParams
     */
    'personalnummer'?: string;
}
/**
 * 
 * @export
 * @interface CreateRolleBodyParams
 */
export interface CreateRolleBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreateRolleBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRolleBodyParams
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {RollenArt}
     * @memberof CreateRolleBodyParams
     */
    'rollenart': RollenArt;
    /**
     * 
     * @type {Set<RollenMerkmal>}
     * @memberof CreateRolleBodyParams
     */
    'merkmale': Set<RollenMerkmal>;
    /**
     * 
     * @type {Set<RollenSystemRecht>}
     * @memberof CreateRolleBodyParams
     */
    'systemrechte': Set<RollenSystemRecht>;
}


/**
 * 
 * @export
 * @interface DBiamPersonResponse
 */
export interface DBiamPersonResponse {
    /**
     * 
     * @type {PersonResponse}
     * @memberof DBiamPersonResponse
     */
    'person': PersonResponse;
    /**
     * 
     * @type {Array<DBiamPersonenkontextResponse>}
     * @memberof DBiamPersonResponse
     */
    'dBiamPersonenkontextResponses': Array<DBiamPersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface DBiamPersonenkontextResponse
 */
export interface DBiamPersonenkontextResponse {
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenkontextResponse
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenkontextResponse
     */
    'organisationId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenkontextResponse
     */
    'rolleId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenkontextResponse
     */
    'befristung': string;
}
/**
 * 
 * @export
 * @interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
 */
export interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response {
    /**
     * 
     * @type {number}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<DBiamPersonenuebersichtResponse>}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'items': Array<DBiamPersonenuebersichtResponse>;
}
/**
 * 
 * @export
 * @interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200ResponseAllOf
 */
export interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200ResponseAllOf {
    /**
     * 
     * @type {Array<DBiamPersonenuebersichtResponse>}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200ResponseAllOf
     */
    'items': Array<DBiamPersonenuebersichtResponse>;
}
/**
 * 
 * @export
 * @interface DBiamPersonenuebersichtResponse
 */
export interface DBiamPersonenuebersichtResponse {
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'nachname': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'benutzername': string;
    /**
     * Date of the most recent changed personenkontext in the Zuordnungen
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'lastModifiedZuordnungen': string | null;
    /**
     * 
     * @type {Array<DBiamPersonenzuordnungResponse>}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'zuordnungen': Array<DBiamPersonenzuordnungResponse>;
}
/**
 * 
 * @export
 * @interface DBiamPersonenzuordnungResponse
 */
export interface DBiamPersonenzuordnungResponse {
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'sskId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'rolleId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'sskName': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'sskDstNr': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'rolle': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'administriertVon': string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'typ': OrganisationsTyp;
    /**
     * 
     * @type {boolean}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'editable': boolean;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'befristung': string;
    /**
     * 
     * @type {RollenMerkmal}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'merkmale': RollenMerkmal;
}


/**
 * 
 * @export
 * @interface DbiamCreatePersonWithPersonenkontexteBodyParams
 */
export interface DbiamCreatePersonWithPersonenkontexteBodyParams {
    /**
     * 
     * @type {string}
     * @memberof DbiamCreatePersonWithPersonenkontexteBodyParams
     */
    'familienname': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamCreatePersonWithPersonenkontexteBodyParams
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamCreatePersonWithPersonenkontexteBodyParams
     */
    'personalnummer'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbiamCreatePersonWithPersonenkontexteBodyParams
     */
    'befristung'?: string;
    /**
     * 
     * @type {Array<DbiamCreatePersonenkontextBodyParams>}
     * @memberof DbiamCreatePersonWithPersonenkontexteBodyParams
     */
    'createPersonenkontexte': Array<DbiamCreatePersonenkontextBodyParams>;
}
/**
 * 
 * @export
 * @interface DbiamCreatePersonenkontextBodyParams
 */
export interface DbiamCreatePersonenkontextBodyParams {
    /**
     * 
     * @type {string}
     * @memberof DbiamCreatePersonenkontextBodyParams
     */
    'organisationId': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamCreatePersonenkontextBodyParams
     */
    'rolleId': string;
}
/**
 * 
 * @export
 * @interface DbiamOrganisationError
 */
export interface DbiamOrganisationError {
    /**
     * 
     * @type {string}
     * @memberof DbiamOrganisationError
     */
    'i18nKey': DbiamOrganisationErrorI18nKeyEnum;
    /**
     * Corresponds to HTTP Status code like 200, 404, 500
     * @type {number}
     * @memberof DbiamOrganisationError
     */
    'code': number;
}

export const DbiamOrganisationErrorI18nKeyEnum = {
    OrganisationSpecificationError: 'ORGANISATION_SPECIFICATION_ERROR',
    KennungRequiredForSchule: 'KENNUNG_REQUIRED_FOR_SCHULE',
    NameRequiredForSchule: 'NAME_REQUIRED_FOR_SCHULE',
    SchuleKennungEindeutig: 'SCHULE_KENNUNG_EINDEUTIG',
    SchuleUnterTraeger: 'SCHULE_UNTER_TRAEGER',
    TraegerInTraeger: 'TRAEGER_IN_TRAEGER',
    NurKlasseUnterSchule: 'NUR_KLASSE_UNTER_SCHULE',
    ZyklusInOrganisation: 'ZYKLUS_IN_ORGANISATION',
    RootOrganisationImmutable: 'ROOT_ORGANISATION_IMMUTABLE',
    KlasseNurVonSchuleAdministriert: 'KLASSE_NUR_VON_SCHULE_ADMINISTRIERT',
    KlassennameAnSchuleEindeutig: 'KLASSENNAME_AN_SCHULE_EINDEUTIG',
    OrganisationIstBereitsZugewiesenError: 'ORGANISATION_IST_BEREITS_ZUGEWIESEN_ERROR',
    NameRequiredForKlasse: 'NAME_REQUIRED_FOR_KLASSE',
    NameEnthaeltLeerzeichen: 'NAME_ENTHAELT_LEERZEICHEN',
    KennungEnthaeltLeerzeichen: 'KENNUNG_ENTHAELT_LEERZEICHEN'
} as const;

export type DbiamOrganisationErrorI18nKeyEnum = typeof DbiamOrganisationErrorI18nKeyEnum[keyof typeof DbiamOrganisationErrorI18nKeyEnum];

/**
 * 
 * @export
 * @interface DbiamPersonError
 */
export interface DbiamPersonError {
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonError
     */
    'i18nKey': DbiamPersonErrorI18nKeyEnum;
    /**
     * Corresponds to HTTP Status code like 200, 404, 500
     * @type {number}
     * @memberof DbiamPersonError
     */
    'code': number;
}

export const DbiamPersonErrorI18nKeyEnum = {
    PersonError: 'PERSON_ERROR',
    VornameEnthaeltLeerzeichen: 'VORNAME_ENTHAELT_LEERZEICHEN',
    FamiliennameEnthaeltLeerzeichen: 'FAMILIENNAME_ENTHAELT_LEERZEICHEN',
    PersonNotFound: 'PERSON_NOT_FOUND',
    DownstreamUnreachable: 'DOWNSTREAM_UNREACHABLE',
    PersonalnummerRequired: 'PERSONALNUMMER_REQUIRED',
    NewerVersionOfPersonalnummerAvailable: 'NEWER_VERSION_OF_PERSONALNUMMER_AVAILABLE',
    PersonalnummerNichtEindeutig: 'PERSONALNUMMER_NICHT_EINDEUTIG'
} as const;

export type DbiamPersonErrorI18nKeyEnum = typeof DbiamPersonErrorI18nKeyEnum[keyof typeof DbiamPersonErrorI18nKeyEnum];

/**
 * 
 * @export
 * @interface DbiamPersonenkontextBodyParams
 */
export interface DbiamPersonenkontextBodyParams {
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextBodyParams
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextBodyParams
     */
    'organisationId': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextBodyParams
     */
    'rolleId': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextBodyParams
     */
    'befristung'?: string;
}
/**
 * 
 * @export
 * @interface DbiamPersonenkontextError
 */
export interface DbiamPersonenkontextError {
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextError
     */
    'i18nKey': DbiamPersonenkontextErrorI18nKeyEnum;
    /**
     * Corresponds to HTTP Status code like 200, 404, 500
     * @type {number}
     * @memberof DbiamPersonenkontextError
     */
    'code': number;
}

export const DbiamPersonenkontextErrorI18nKeyEnum = {
    PersonenkontextSpecificationError: 'PERSONENKONTEXT_SPECIFICATION_ERROR',
    NurLehrUndLernAnKlasse: 'NUR_LEHR_UND_LERN_AN_KLASSE',
    GleicheRolleAnKlasseWieSchule: 'GLEICHE_ROLLE_AN_KLASSE_WIE_SCHULE',
    OrganisationMatchesRollenart: 'ORGANISATION_MATCHES_ROLLENART',
    PersonenkontextAnlageError: 'PERSONENKONTEXT_ANLAGE_ERROR',
    RolleNurAnPassendeOrganisation: 'ROLLE_NUR_AN_PASSENDE_ORGANISATION',
    PersonalnummerNichtEindeutig: 'PERSONALNUMMER_NICHT_EINDEUTIG'
} as const;

export type DbiamPersonenkontextErrorI18nKeyEnum = typeof DbiamPersonenkontextErrorI18nKeyEnum[keyof typeof DbiamPersonenkontextErrorI18nKeyEnum];

/**
 * 
 * @export
 * @interface DbiamPersonenkontextMigrationBodyParams
 */
export interface DbiamPersonenkontextMigrationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextMigrationBodyParams
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextMigrationBodyParams
     */
    'organisationId': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextMigrationBodyParams
     */
    'rolleId': string;
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextMigrationBodyParams
     */
    'befristung'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontextMigrationBodyParams
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface DbiamPersonenkontexteUpdateError
 */
export interface DbiamPersonenkontexteUpdateError {
    /**
     * 
     * @type {string}
     * @memberof DbiamPersonenkontexteUpdateError
     */
    'i18nKey': DbiamPersonenkontexteUpdateErrorI18nKeyEnum;
    /**
     * Corresponds to HTTP Status code like 200, 404, 500
     * @type {number}
     * @memberof DbiamPersonenkontexteUpdateError
     */
    'code': number;
}

export const DbiamPersonenkontexteUpdateErrorI18nKeyEnum = {
    PersonenkontexteUpdateError: 'PERSONENKONTEXTE_UPDATE_ERROR',
    PersonenkontextNotFound: 'PERSONENKONTEXT_NOT_FOUND',
    CountMismatching: 'COUNT_MISMATCHING',
    NewerVersionOfPersonenkontexteAvailable: 'NEWER_VERSION_OF_PERSONENKONTEXTE_AVAILABLE',
    InvalidLastModifiedValue: 'INVALID_LAST_MODIFIED_VALUE',
    PersonIdMismatch: 'PERSON_ID_MISMATCH',
    PersonNotFound: 'PERSON_NOT_FOUND',
    InvalidPersonenkontextForPersonWithRollenartLern: 'INVALID_PERSONENKONTEXT_FOR_PERSON_WITH_ROLLENART_LERN',
    BefristungRequiredForPersonenkontext: ' BEFRISTUNG_REQUIRED_FOR_PERSONENKONTEXT'
} as const;

export type DbiamPersonenkontexteUpdateErrorI18nKeyEnum = typeof DbiamPersonenkontexteUpdateErrorI18nKeyEnum[keyof typeof DbiamPersonenkontexteUpdateErrorI18nKeyEnum];

/**
 * 
 * @export
 * @interface DbiamRolleError
 */
export interface DbiamRolleError {
    /**
     * 
     * @type {string}
     * @memberof DbiamRolleError
     */
    'i18nKey': DbiamRolleErrorI18nKeyEnum;
    /**
     * Corresponds to HTTP Status code like 200, 404, 500
     * @type {number}
     * @memberof DbiamRolleError
     */
    'code': number;
}

export const DbiamRolleErrorI18nKeyEnum = {
    RolleError: 'ROLLE_ERROR',
    AddSystemrechtError: 'ADD_SYSTEMRECHT_ERROR',
    RolleHatPersonenkontexteError: 'ROLLE_HAT_PERSONENKONTEXTE_ERROR',
    UpdateMerkmaleError: 'UPDATE_MERKMALE_ERROR',
    RollennameEnthaeltLeerzeichen: 'ROLLENNAME_ENTHAELT_LEERZEICHEN',
    NewerVersionOfRolleAvailable: 'NEWER_VERSION_OF_ROLLE_AVAILABLE'
} as const;

export type DbiamRolleErrorI18nKeyEnum = typeof DbiamRolleErrorI18nKeyEnum[keyof typeof DbiamRolleErrorI18nKeyEnum];

/**
 * 
 * @export
 * @interface DbiamUpdatePersonenkontexteBodyParams
 */
export interface DbiamUpdatePersonenkontexteBodyParams {
    /**
     * Date of the most recent changed personenkontext
     * @type {string}
     * @memberof DbiamUpdatePersonenkontexteBodyParams
     */
    'lastModified'?: string | null;
    /**
     * The amount of personenkontexte
     * @type {number}
     * @memberof DbiamUpdatePersonenkontexteBodyParams
     */
    'count': number;
    /**
     * 
     * @type {Array<DbiamPersonenkontextBodyParams>}
     * @memberof DbiamUpdatePersonenkontexteBodyParams
     */
    'personenkontexte': Array<DbiamPersonenkontextBodyParams>;
}
/**
 * 
 * @export
 * @interface DeleteRevisionBodyParams
 */
export interface DeleteRevisionBodyParams {
    /**
     * The revision of a personenkontext.
     * @type {string}
     * @memberof DeleteRevisionBodyParams
     */
    'revision': string;
}
/**
 * 
 * @export
 * @interface FindRollenResponse
 */
export interface FindRollenResponse {
    /**
     * 
     * @type {Array<RolleResponse>}
     * @memberof FindRollenResponse
     */
    'moeglicheRollen': Array<RolleResponse>;
    /**
     * 
     * @type {number}
     * @memberof FindRollenResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface FindSchulstrukturknotenResponse
 */
export interface FindSchulstrukturknotenResponse {
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof FindSchulstrukturknotenResponse
     */
    'moeglicheSsks': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {number}
     * @memberof FindSchulstrukturknotenResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Geschlecht = {
    M: 'm',
    W: 'w',
    D: 'd',
    X: 'x'
} as const;

export type Geschlecht = typeof Geschlecht[keyof typeof Geschlecht];


/**
 * 
 * @export
 * @interface LockUserBodyParams
 */
export interface LockUserBodyParams {
    /**
     * 
     * @type {boolean}
     * @memberof LockUserBodyParams
     */
    'lock': boolean;
    /**
     * 
     * @type {string}
     * @memberof LockUserBodyParams
     */
    'locked_from': string;
}
/**
 * 
 * @export
 * @interface LoeschungResponse
 */
export interface LoeschungResponse {
    /**
     * 
     * @type {string}
     * @memberof LoeschungResponse
     */
    'zeitpunkt': string;
}
/**
 * 
 * @export
 * @interface OrganisationByIdBodyParams
 */
export interface OrganisationByIdBodyParams {
    /**
     * The id of an organization
     * @type {string}
     * @memberof OrganisationByIdBodyParams
     */
    'organisationId': string;
}
/**
 * 
 * @export
 * @interface OrganisationByNameBodyParams
 */
export interface OrganisationByNameBodyParams {
    /**
     * 
     * @type {string}
     * @memberof OrganisationByNameBodyParams
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface OrganisationResponse
 */
export interface OrganisationResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'administriertVon': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'kennung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'namensergaenzung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'kuerzel': string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof OrganisationResponse
     */
    'typ': OrganisationsTyp;
    /**
     * 
     * @type {TraegerschaftTyp}
     * @memberof OrganisationResponse
     */
    'traegerschaft': TraegerschaftTyp;
}


/**
 * 
 * @export
 * @interface OrganisationResponseLegacy
 */
export interface OrganisationResponseLegacy {
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'administriertVon': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'kennung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'namensergaenzung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'kuerzel': string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof OrganisationResponseLegacy
     */
    'typ': OrganisationsTyp;
}


/**
 * 
 * @export
 * @interface OrganisationRootChildrenResponse
 */
export interface OrganisationRootChildrenResponse {
    /**
     * 
     * @type {OrganisationResponse}
     * @memberof OrganisationRootChildrenResponse
     */
    'oeffentlich': OrganisationResponse;
    /**
     * 
     * @type {OrganisationResponse}
     * @memberof OrganisationRootChildrenResponse
     */
    'ersatz': OrganisationResponse;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrganisationsTyp = {
    Root: 'ROOT',
    Land: 'LAND',
    Traeger: 'TRAEGER',
    Schule: 'SCHULE',
    Klasse: 'KLASSE',
    Anbieter: 'ANBIETER',
    SonstigeOrganisationEinrichtung: 'SONSTIGE ORGANISATION / EINRICHTUNG',
    Unbestaetigt: 'UNBESTAETIGT'
} as const;

export type OrganisationsTyp = typeof OrganisationsTyp[keyof typeof OrganisationsTyp];


/**
 * 
 * @export
 * @interface ParentOrganisationenResponse
 */
export interface ParentOrganisationenResponse {
    /**
     * 
     * @type {Array<OrganisationResponse>}
     * @memberof ParentOrganisationenResponse
     */
    'parents': Array<OrganisationResponse>;
}
/**
 * 
 * @export
 * @interface ParentOrganisationsByIdsBodyParams
 */
export interface ParentOrganisationsByIdsBodyParams {
    /**
     * The ids of organizations
     * @type {Array<string>}
     * @memberof ParentOrganisationsByIdsBodyParams
     */
    'organisationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'referrer': string | null;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'mandant': string;
    /**
     * 
     * @type {PersonNameResponse}
     * @memberof Person
     */
    'name': PersonNameResponse;
    /**
     * 
     * @type {PersonBirthResponse}
     * @memberof Person
     */
    'geburt': PersonBirthResponse | null;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'stammorganisation': string | null;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'geschlecht': string | null;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'lokalisierung': string | null;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof Person
     */
    'vertrauensstufe': Vertrauensstufe;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'revision': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'personalnummer': string | null;
}


/**
 * 
 * @export
 * @interface PersonBirthParams
 */
export interface PersonBirthParams {
    /**
     * 
     * @type {string}
     * @memberof PersonBirthParams
     */
    'datum'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonBirthParams
     */
    'geburtsort'?: string;
}
/**
 * 
 * @export
 * @interface PersonBirthResponse
 */
export interface PersonBirthResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonBirthResponse
     */
    'datum': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonBirthResponse
     */
    'geburtsort': string | null;
}
/**
 * 
 * @export
 * @interface PersonByPersonalnummerBodyParams
 */
export interface PersonByPersonalnummerBodyParams {
    /**
     * 
     * @type {string}
     * @memberof PersonByPersonalnummerBodyParams
     */
    'personalnummer': string;
    /**
     * Date of the most recent changed Personalnummer
     * @type {string}
     * @memberof PersonByPersonalnummerBodyParams
     */
    'lastModified': string;
    /**
     * 
     * @type {string}
     * @memberof PersonByPersonalnummerBodyParams
     */
    'revision': string;
}
/**
 * 
 * @export
 * @interface PersonControllerFindPersonenkontexte200Response
 */
export interface PersonControllerFindPersonenkontexte200Response {
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'items': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonControllerFindPersonenkontexte200ResponseAllOf
 */
export interface PersonControllerFindPersonenkontexte200ResponseAllOf {
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonControllerFindPersonenkontexte200ResponseAllOf
     */
    'items': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonFrontendControllerFindPersons200Response
 */
export interface PersonFrontendControllerFindPersons200Response {
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<PersonendatensatzResponse>}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'items': Array<PersonendatensatzResponse>;
}
/**
 * 
 * @export
 * @interface PersonFrontendControllerFindPersons200ResponseAllOf
 */
export interface PersonFrontendControllerFindPersons200ResponseAllOf {
    /**
     * 
     * @type {Array<PersonendatensatzResponse>}
     * @memberof PersonFrontendControllerFindPersons200ResponseAllOf
     */
    'items': Array<PersonendatensatzResponse>;
}
/**
 * 
 * @export
 * @interface PersonIdResponse
 */
export interface PersonIdResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonIdResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface PersonInfoResponse
 */
export interface PersonInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonInfoResponse
     */
    'pid': string;
    /**
     * 
     * @type {Person}
     * @memberof PersonInfoResponse
     */
    'person': Person;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonInfoResponse
     */
    'personenkontexte': Array<PersonenkontextResponse>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonInfoResponse
     */
    'gruppen': Array<string>;
}
/**
 * 
 * @export
 * @interface PersonLockResponse
 */
export interface PersonLockResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonLockResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PersonNameParams
 */
export interface PersonNameParams {
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'familienname': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'initialenfamilienname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'initialenvorname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'rufname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'titel'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'anrede'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'namenssuffix'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'namenspraefix'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'sortierindex'?: string;
}
/**
 * 
 * @export
 * @interface PersonNameResponse
 */
export interface PersonNameResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonNameResponse
     */
    'familiennamen': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameResponse
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameResponse
     */
    'initialenfamilienname': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonNameResponse
     */
    'initialenvorname': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonNameResponse
     */
    'rufname': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonNameResponse
     */
    'titel': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameResponse
     */
    'anrede': Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameResponse
     */
    'namenspraefix': Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameResponse
     */
    'namenssuffix': Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PersonNameResponse
     */
    'sortierindex': string | null;
}
/**
 * 
 * @export
 * @interface PersonResponse
 */
export interface PersonResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'referrer': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'mandant': string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof PersonResponse
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof PersonResponse
     */
    'geburt': PersonBirthParams | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'stammorganisation': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'geschlecht': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'lokalisierung': string | null;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof PersonResponse
     */
    'vertrauensstufe': Vertrauensstufe;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'revision': string;
    /**
     * Initiales Benutzerpasswort, muss nach der ersten Anmeldung geändert werden
     * @type {string}
     * @memberof PersonResponse
     */
    'startpasswort': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'personalnummer': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PersonResponse
     */
    'isLocked': boolean | null;
    /**
     * 
     * @type {object}
     * @memberof PersonResponse
     */
    'lockInfo': object | null;
    /**
     * Date of the most recent changes for the person
     * @type {string}
     * @memberof PersonResponse
     */
    'lastModified': string;
}


/**
 * 
 * @export
 * @interface PersonResponseAutomapper
 */
export interface PersonResponseAutomapper {
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'referrer': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'mandant': string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof PersonResponseAutomapper
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof PersonResponseAutomapper
     */
    'geburt': PersonBirthParams;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'stammorganisation': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'geschlecht': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'lokalisierung': string;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof PersonResponseAutomapper
     */
    'vertrauensstufe': Vertrauensstufe;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'revision': string;
    /**
     * Initiales Benutzerpasswort, muss nach der ersten Anmeldung geändert werden
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'startpasswort': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'personalnummer': string;
}


/**
 * 
 * @export
 * @interface PersonendatensatzResponse
 */
export interface PersonendatensatzResponse {
    /**
     * 
     * @type {PersonResponse}
     * @memberof PersonendatensatzResponse
     */
    'person': PersonResponse;
}
/**
 * 
 * @export
 * @interface PersonendatensatzResponseAutomapper
 */
export interface PersonendatensatzResponseAutomapper {
    /**
     * 
     * @type {PersonResponseAutomapper}
     * @memberof PersonendatensatzResponseAutomapper
     */
    'person': PersonResponseAutomapper;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonendatensatzResponseAutomapper
     */
    'personenkontexte': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonenkontextResponse
 */
export interface PersonenkontextResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'referrer': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'mandant': string;
    /**
     * 
     * @type {object}
     * @memberof PersonenkontextResponse
     */
    'organisation': object;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'roleName': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'personenstatus': PersonenkontextResponsePersonenstatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'jahrgangsstufe': PersonenkontextResponseJahrgangsstufeEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'sichtfreigabe': PersonenkontextResponseSichtfreigabeEnum;
    /**
     * 
     * @type {LoeschungResponse}
     * @memberof PersonenkontextResponse
     */
    'loeschung': LoeschungResponse | null;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'revision': string;
}

export const PersonenkontextResponsePersonenstatusEnum = {
    Aktiv: 'AKTIV'
} as const;

export type PersonenkontextResponsePersonenstatusEnum = typeof PersonenkontextResponsePersonenstatusEnum[keyof typeof PersonenkontextResponsePersonenstatusEnum];
export const PersonenkontextResponseJahrgangsstufeEnum = {
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10'
} as const;

export type PersonenkontextResponseJahrgangsstufeEnum = typeof PersonenkontextResponseJahrgangsstufeEnum[keyof typeof PersonenkontextResponseJahrgangsstufeEnum];
export const PersonenkontextResponseSichtfreigabeEnum = {
    Ja: 'ja',
    Nein: 'nein'
} as const;

export type PersonenkontextResponseSichtfreigabeEnum = typeof PersonenkontextResponseSichtfreigabeEnum[keyof typeof PersonenkontextResponseSichtfreigabeEnum];

/**
 * 
 * @export
 * @interface PersonenkontextRolleFieldsResponse
 */
export interface PersonenkontextRolleFieldsResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextRolleFieldsResponse
     */
    'organisationsId': string;
    /**
     * 
     * @type {RollenSystemRechtServiceProviderIDResponse}
     * @memberof PersonenkontextRolleFieldsResponse
     */
    'rolle': RollenSystemRechtServiceProviderIDResponse;
}
/**
 * 
 * @export
 * @interface PersonenkontextWorkflowResponse
 */
export interface PersonenkontextWorkflowResponse {
    /**
     * List of available organisations.
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof PersonenkontextWorkflowResponse
     */
    'organisations': Array<OrganisationResponseLegacy>;
    /**
     * List of available roles.
     * @type {Array<RolleResponse>}
     * @memberof PersonenkontextWorkflowResponse
     */
    'rollen': Array<RolleResponse>;
    /**
     * Selected organisation.
     * @type {string}
     * @memberof PersonenkontextWorkflowResponse
     */
    'selectedOrganisation': string | null;
    /**
     * Selected rolle.
     * @type {string}
     * @memberof PersonenkontextWorkflowResponse
     */
    'selectedRolle': string | null;
    /**
     * Indicates whether the commit action can be performed.
     * @type {boolean}
     * @memberof PersonenkontextWorkflowResponse
     */
    'canCommit': boolean;
}
/**
 * 
 * @export
 * @interface PersonenkontextdatensatzResponse
 */
export interface PersonenkontextdatensatzResponse {
    /**
     * 
     * @type {PersonIdResponse}
     * @memberof PersonenkontextdatensatzResponse
     */
    'person': PersonIdResponse;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonenkontextdatensatzResponse
     */
    'personenkontexte': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonenkontexteUpdateResponse
 */
export interface PersonenkontexteUpdateResponse {
    /**
     * 
     * @type {Array<DBiamPersonenkontextResponse>}
     * @memberof PersonenkontexteUpdateResponse
     */
    'dBiamPersonenkontextResponses': Array<DBiamPersonenkontextResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Personenstatus = {
    Aktiv: 'AKTIV'
} as const;

export type Personenstatus = typeof Personenstatus[keyof typeof Personenstatus];


/**
 * 
 * @export
 * @interface PersonenuebersichtBodyParams
 */
export interface PersonenuebersichtBodyParams {
    /**
     * The offset of the paginated list.
     * @type {number}
     * @memberof PersonenuebersichtBodyParams
     */
    'offset'?: number;
    /**
     * The requested limit for the page size.
     * @type {number}
     * @memberof PersonenuebersichtBodyParams
     */
    'limit'?: number;
    /**
     * An array of IDs for the persons.
     * @type {Array<string>}
     * @memberof PersonenuebersichtBodyParams
     */
    'personIds': Array<string>;
}
/**
 * 
 * @export
 * @interface RawPagedResponse
 */
export interface RawPagedResponse {
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'limit': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RawPagedResponse
     */
    'items': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Rolle = {
    Lern: 'LERN',
    Lehr: 'LEHR',
    Extern: 'EXTERN',
    Orgadmin: 'ORGADMIN',
    Leit: 'LEIT',
    Sysadmin: 'SYSADMIN'
} as const;

export type Rolle = typeof Rolle[keyof typeof Rolle];


/**
 * 
 * @export
 * @interface RolleResponse
 */
export interface RolleResponse {
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {RollenArt}
     * @memberof RolleResponse
     */
    'rollenart': RollenArt;
    /**
     * 
     * @type {Set<RollenMerkmal>}
     * @memberof RolleResponse
     */
    'merkmale': Set<RollenMerkmal>;
    /**
     * 
     * @type {Set<RollenSystemRecht>}
     * @memberof RolleResponse
     */
    'systemrechte': Set<RollenSystemRecht>;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'administeredBySchulstrukturknotenName': string | null;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'administeredBySchulstrukturknotenKennung': string | null;
    /**
     * 
     * @type {number}
     * @memberof RolleResponse
     */
    'version': number;
}


/**
 * 
 * @export
 * @interface RolleServiceProviderBodyParams
 */
export interface RolleServiceProviderBodyParams {
    /**
     * The id for the service provider.
     * @type {string}
     * @memberof RolleServiceProviderBodyParams
     */
    'serviceProviderId': string;
    /**
     * The version for the rolle.
     * @type {number}
     * @memberof RolleServiceProviderBodyParams
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface RolleServiceProviderResponse
 */
export interface RolleServiceProviderResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof RolleServiceProviderResponse
     */
    'serviceProviderIds': Array<string>;
}
/**
 * 
 * @export
 * @interface RolleWithServiceProvidersResponse
 */
export interface RolleWithServiceProvidersResponse {
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {RollenArt}
     * @memberof RolleWithServiceProvidersResponse
     */
    'rollenart': RollenArt;
    /**
     * 
     * @type {Set<RollenMerkmal>}
     * @memberof RolleWithServiceProvidersResponse
     */
    'merkmale': Set<RollenMerkmal>;
    /**
     * 
     * @type {Set<RollenSystemRecht>}
     * @memberof RolleWithServiceProvidersResponse
     */
    'systemrechte': Set<RollenSystemRecht>;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'administeredBySchulstrukturknotenName': string | null;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'administeredBySchulstrukturknotenKennung': string | null;
    /**
     * 
     * @type {number}
     * @memberof RolleWithServiceProvidersResponse
     */
    'version': number;
    /**
     * 
     * @type {Array<ServiceProviderIdNameResponse>}
     * @memberof RolleWithServiceProvidersResponse
     */
    'serviceProviders': Array<ServiceProviderIdNameResponse>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RollenArt = {
    Lern: 'LERN',
    Lehr: 'LEHR',
    Extern: 'EXTERN',
    Orgadmin: 'ORGADMIN',
    Leit: 'LEIT',
    Sysadmin: 'SYSADMIN'
} as const;

export type RollenArt = typeof RollenArt[keyof typeof RollenArt];


/**
 * 
 * @export
 * @enum {string}
 */

export const RollenMerkmal = {
    BefristungPflicht: 'BEFRISTUNG_PFLICHT',
    KopersPflicht: 'KOPERS_PFLICHT'
} as const;

export type RollenMerkmal = typeof RollenMerkmal[keyof typeof RollenMerkmal];


/**
 * 
 * @export
 * @enum {string}
 */

export const RollenSystemRecht = {
    RollenVerwalten: 'ROLLEN_VERWALTEN',
    PersonenSofortLoeschen: 'PERSONEN_SOFORT_LOESCHEN',
    PersonenVerwalten: 'PERSONEN_VERWALTEN',
    SchulenVerwalten: 'SCHULEN_VERWALTEN',
    KlassenVerwalten: 'KLASSEN_VERWALTEN',
    SchultraegerVerwalten: 'SCHULTRAEGER_VERWALTEN',
    MigrationDurchfuehren: 'MIGRATION_DURCHFUEHREN'
} as const;

export type RollenSystemRecht = typeof RollenSystemRecht[keyof typeof RollenSystemRecht];


/**
 * 
 * @export
 * @interface RollenSystemRechtServiceProviderIDResponse
 */
export interface RollenSystemRechtServiceProviderIDResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof RollenSystemRechtServiceProviderIDResponse
     */
    'systemrechte': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RollenSystemRechtServiceProviderIDResponse
     */
    'serviceProviderIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ServiceProviderIdNameResponse
 */
export interface ServiceProviderIdNameResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderIdNameResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderIdNameResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceProviderKategorie = {
    Email: 'EMAIL',
    Unterricht: 'UNTERRICHT',
    Verwaltung: 'VERWALTUNG',
    Hinweise: 'HINWEISE',
    Angebote: 'ANGEBOTE'
} as const;

export type ServiceProviderKategorie = typeof ServiceProviderKategorie[keyof typeof ServiceProviderKategorie];


/**
 * 
 * @export
 * @interface ServiceProviderResponse
 */
export interface ServiceProviderResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'name': string;
    /**
     * 
     * @type {ServiceProviderTarget}
     * @memberof ServiceProviderResponse
     */
    'target': ServiceProviderTarget;
    /**
     * Can be undefined, if `target` is not equal to `URL`
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'url': string;
    /**
     * 
     * @type {ServiceProviderKategorie}
     * @memberof ServiceProviderResponse
     */
    'kategorie': ServiceProviderKategorie;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderResponse
     */
    'hasLogo': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderResponse
     */
    'requires2fa': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceProviderTarget = {
    Url: 'URL',
    Email: 'EMAIL',
    SchulportalAdministration: 'SCHULPORTAL_ADMINISTRATION'
} as const;

export type ServiceProviderTarget = typeof ServiceProviderTarget[keyof typeof ServiceProviderTarget];


/**
 * 
 * @export
 * @enum {string}
 */

export const Sichtfreigabe = {
    Ja: 'ja',
    Nein: 'nein'
} as const;

export type Sichtfreigabe = typeof Sichtfreigabe[keyof typeof Sichtfreigabe];


/**
 * 
 * @export
 * @interface SystemrechtResponse
 */
export interface SystemrechtResponse {
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'ROLLEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'KLASSEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'SCHULEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'PERSONEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'SCHULTRAEGER_VERWALTEN': Array<OrganisationResponseLegacy>;
}
/**
 * 
 * @export
 * @interface TokenInitBodyParams
 */
export interface TokenInitBodyParams {
    /**
     * 
     * @type {string}
     * @memberof TokenInitBodyParams
     */
    'personId': string;
}
/**
 * 
 * @export
 * @interface TokenRequiredResponse
 */
export interface TokenRequiredResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TokenRequiredResponse
     */
    'required': boolean;
}
/**
 * 
 * @export
 * @interface TokenStateResponse
 */
export interface TokenStateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TokenStateResponse
     */
    'hasToken': boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenStateResponse
     */
    'tokenKind': string;
    /**
     * 
     * @type {string}
     * @memberof TokenStateResponse
     */
    'serial': string;
}
/**
 * 
 * @export
 * @interface TokenVerifyBodyParams
 */
export interface TokenVerifyBodyParams {
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyBodyParams
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof TokenVerifyBodyParams
     */
    'otp': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TraegerschaftTyp = {
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06'
} as const;

export type TraegerschaftTyp = typeof TraegerschaftTyp[keyof typeof TraegerschaftTyp];


/**
 * 
 * @export
 * @interface UpdateOrganisationBodyParams
 */
export interface UpdateOrganisationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'administriertVon'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'zugehoerigZu'?: string;
    /**
     * Required, if `typ` is equal to `SCHULE`
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'kennung'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'namensergaenzung'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'kuerzel'?: string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof UpdateOrganisationBodyParams
     */
    'typ': OrganisationsTyp;
    /**
     * 
     * @type {TraegerschaftTyp}
     * @memberof UpdateOrganisationBodyParams
     */
    'traegerschaft'?: TraegerschaftTyp;
}


/**
 * 
 * @export
 * @interface UpdatePersonBodyParams
 */
export interface UpdatePersonBodyParams {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'stammorganisation'?: string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof UpdatePersonBodyParams
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof UpdatePersonBodyParams
     */
    'geburt'?: PersonBirthParams;
    /**
     * 
     * @type {Geschlecht}
     * @memberof UpdatePersonBodyParams
     */
    'geschlecht'?: Geschlecht;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'lokalisierung'?: string;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof UpdatePersonBodyParams
     */
    'vertrauensstufe'?: Vertrauensstufe;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePersonBodyParams
     */
    'auskunftssperre'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'revision': string;
}


/**
 * 
 * @export
 * @interface UpdateRolleBodyParams
 */
export interface UpdateRolleBodyParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateRolleBodyParams
     */
    'name': string;
    /**
     * 
     * @type {Set<RollenMerkmal>}
     * @memberof UpdateRolleBodyParams
     */
    'merkmale': Set<RollenMerkmal>;
    /**
     * 
     * @type {Set<RollenSystemRecht>}
     * @memberof UpdateRolleBodyParams
     */
    'systemrechte': Set<RollenSystemRecht>;
    /**
     * 
     * @type {Set<string>}
     * @memberof UpdateRolleBodyParams
     */
    'serviceProviderIds': Set<string>;
    /**
     * 
     * @type {number}
     * @memberof UpdateRolleBodyParams
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface UserinfoResponse
 */
export interface UserinfoResponse {
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'sub': string;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'personId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'given_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'family_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'middle_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'preferred_username': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'profile': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'picture': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'website': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'email': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserinfoResponse
     */
    'email_verified': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'zoneinfo': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'locale': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'phone_number': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'updated_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'password_updated_at': string | null;
    /**
     * 
     * @type {Array<PersonenkontextRolleFieldsResponse>}
     * @memberof UserinfoResponse
     */
    'personenkontexte': Array<PersonenkontextRolleFieldsResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Vertrauensstufe = {
    Kein: 'KEIN',
    Unbe: 'UNBE',
    Teil: 'TEIL',
    Voll: 'VOLL'
} as const;

export type Vertrauensstufe = typeof Vertrauensstufe[keyof typeof Vertrauensstufe];



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logininfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogin: async (redirectUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redirect to Keycloak password reset.
         * @param {string} redirectUrl 
         * @param {string} loginHint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerResetPassword: async (redirectUrl: string, loginHint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUrl' is not null or undefined
            assertParamExists('authenticationControllerResetPassword', 'redirectUrl', redirectUrl)
            // verify required parameter 'loginHint' is not null or undefined
            assertParamExists('authenticationControllerResetPassword', 'loginHint', loginHint)
            const localVarPath = `/api/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }

            if (loginHint !== undefined) {
                localVarQueryParameter['login_hint'] = loginHint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserinfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerLogin(redirectUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redirect to Keycloak password reset.
         * @param {string} redirectUrl 
         * @param {string} loginHint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerResetPassword(redirectUrl: string, loginHint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerResetPassword(redirectUrl, loginHint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerInfo(options?: any): AxiosPromise<UserinfoResponse> {
            return localVarFp.authenticationControllerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogin(redirectUrl?: string, options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerLogin(redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogout(options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redirect to Keycloak password reset.
         * @param {string} redirectUrl 
         * @param {string} loginHint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerResetPassword(redirectUrl: string, loginHint: string, options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerResetPassword(redirectUrl, loginHint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 
     * @summary Info about logged in user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerInfo(options?: AxiosRequestConfig): AxiosPromise<UserinfoResponse>;

    /**
     * 
     * @summary Used to start OIDC authentication.
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Used to log out the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerLogout(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Redirect to Keycloak password reset.
     * @param {string} redirectUrl 
     * @param {string} loginHint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerResetPassword(redirectUrl: string, loginHint: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 
     * @summary Info about logged in user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerInfo(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to start OIDC authentication.
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerLogin(redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to log out the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redirect to Keycloak password reset.
     * @param {string} redirectUrl 
     * @param {string} loginHint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerResetPassword(redirectUrl: string, loginHint: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerResetPassword(redirectUrl, loginHint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Class2FAApi - axios parameter creator
 * @export
 */
export const Class2FAApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssignHardwareTokenBodyParams} assignHardwareTokenBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerAssignHardwareToken: async (assignHardwareTokenBodyParams: AssignHardwareTokenBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignHardwareTokenBodyParams' is not null or undefined
            assertParamExists('privacyIdeaAdministrationControllerAssignHardwareToken', 'assignHardwareTokenBodyParams', assignHardwareTokenBodyParams)
            const localVarPath = `/api/2fa-token/assign/hardwareToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignHardwareTokenBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerGetTwoAuthState: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('privacyIdeaAdministrationControllerGetTwoAuthState', 'personId', personId)
            const localVarPath = `/api/2fa-token/state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenInitBodyParams} tokenInitBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerInitializeSoftwareToken: async (tokenInitBodyParams: TokenInitBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenInitBodyParams' is not null or undefined
            assertParamExists('privacyIdeaAdministrationControllerInitializeSoftwareToken', 'tokenInitBodyParams', tokenInitBodyParams)
            const localVarPath = `/api/2fa-token/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenInitBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication', 'personId', personId)
            const localVarPath = `/api/2fa-token/required`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerResetToken: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('privacyIdeaAdministrationControllerResetToken', 'personId', personId)
            const localVarPath = `/api/2fa-token/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenVerifyBodyParams} tokenVerifyBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerVerifyToken: async (tokenVerifyBodyParams: TokenVerifyBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerifyBodyParams' is not null or undefined
            assertParamExists('privacyIdeaAdministrationControllerVerifyToken', 'tokenVerifyBodyParams', tokenVerifyBodyParams)
            const localVarPath = `/api/2fa-token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerifyBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2FAApi - functional programming interface
 * @export
 */
export const Class2FAApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2FAApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AssignHardwareTokenBodyParams} assignHardwareTokenBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async privacyIdeaAdministrationControllerAssignHardwareToken(assignHardwareTokenBodyParams: AssignHardwareTokenBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignHardwareTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.privacyIdeaAdministrationControllerAssignHardwareToken(assignHardwareTokenBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async privacyIdeaAdministrationControllerGetTwoAuthState(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.privacyIdeaAdministrationControllerGetTwoAuthState(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenInitBodyParams} tokenInitBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async privacyIdeaAdministrationControllerInitializeSoftwareToken(tokenInitBodyParams: TokenInitBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.privacyIdeaAdministrationControllerInitializeSoftwareToken(tokenInitBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRequiredResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async privacyIdeaAdministrationControllerResetToken(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.privacyIdeaAdministrationControllerResetToken(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenVerifyBodyParams} tokenVerifyBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async privacyIdeaAdministrationControllerVerifyToken(tokenVerifyBodyParams: TokenVerifyBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.privacyIdeaAdministrationControllerVerifyToken(tokenVerifyBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Class2FAApi - factory interface
 * @export
 */
export const Class2FAApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2FAApiFp(configuration)
    return {
        /**
         * 
         * @param {AssignHardwareTokenBodyParams} assignHardwareTokenBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerAssignHardwareToken(assignHardwareTokenBodyParams: AssignHardwareTokenBodyParams, options?: any): AxiosPromise<AssignHardwareTokenResponse> {
            return localVarFp.privacyIdeaAdministrationControllerAssignHardwareToken(assignHardwareTokenBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerGetTwoAuthState(personId: string, options?: any): AxiosPromise<TokenStateResponse> {
            return localVarFp.privacyIdeaAdministrationControllerGetTwoAuthState(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenInitBodyParams} tokenInitBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerInitializeSoftwareToken(tokenInitBodyParams: TokenInitBodyParams, options?: any): AxiosPromise<string> {
            return localVarFp.privacyIdeaAdministrationControllerInitializeSoftwareToken(tokenInitBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication(personId: string, options?: any): AxiosPromise<TokenRequiredResponse> {
            return localVarFp.privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerResetToken(personId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.privacyIdeaAdministrationControllerResetToken(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenVerifyBodyParams} tokenVerifyBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        privacyIdeaAdministrationControllerVerifyToken(tokenVerifyBodyParams: TokenVerifyBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.privacyIdeaAdministrationControllerVerifyToken(tokenVerifyBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2FAApi - interface
 * @export
 * @interface Class2FAApi
 */
export interface Class2FAApiInterface {
    /**
     * 
     * @param {AssignHardwareTokenBodyParams} assignHardwareTokenBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApiInterface
     */
    privacyIdeaAdministrationControllerAssignHardwareToken(assignHardwareTokenBodyParams: AssignHardwareTokenBodyParams, options?: AxiosRequestConfig): AxiosPromise<AssignHardwareTokenResponse>;

    /**
     * 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApiInterface
     */
    privacyIdeaAdministrationControllerGetTwoAuthState(personId: string, options?: AxiosRequestConfig): AxiosPromise<TokenStateResponse>;

    /**
     * 
     * @param {TokenInitBodyParams} tokenInitBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApiInterface
     */
    privacyIdeaAdministrationControllerInitializeSoftwareToken(tokenInitBodyParams: TokenInitBodyParams, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApiInterface
     */
    privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication(personId: string, options?: AxiosRequestConfig): AxiosPromise<TokenRequiredResponse>;

    /**
     * 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApiInterface
     */
    privacyIdeaAdministrationControllerResetToken(personId: string, options?: AxiosRequestConfig): AxiosPromise<boolean>;

    /**
     * 
     * @param {TokenVerifyBodyParams} tokenVerifyBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApiInterface
     */
    privacyIdeaAdministrationControllerVerifyToken(tokenVerifyBodyParams: TokenVerifyBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Class2FAApi - object-oriented interface
 * @export
 * @class Class2FAApi
 * @extends {BaseAPI}
 */
export class Class2FAApi extends BaseAPI implements Class2FAApiInterface {
    /**
     * 
     * @param {AssignHardwareTokenBodyParams} assignHardwareTokenBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApi
     */
    public privacyIdeaAdministrationControllerAssignHardwareToken(assignHardwareTokenBodyParams: AssignHardwareTokenBodyParams, options?: AxiosRequestConfig) {
        return Class2FAApiFp(this.configuration).privacyIdeaAdministrationControllerAssignHardwareToken(assignHardwareTokenBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApi
     */
    public privacyIdeaAdministrationControllerGetTwoAuthState(personId: string, options?: AxiosRequestConfig) {
        return Class2FAApiFp(this.configuration).privacyIdeaAdministrationControllerGetTwoAuthState(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenInitBodyParams} tokenInitBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApi
     */
    public privacyIdeaAdministrationControllerInitializeSoftwareToken(tokenInitBodyParams: TokenInitBodyParams, options?: AxiosRequestConfig) {
        return Class2FAApiFp(this.configuration).privacyIdeaAdministrationControllerInitializeSoftwareToken(tokenInitBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApi
     */
    public privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication(personId: string, options?: AxiosRequestConfig) {
        return Class2FAApiFp(this.configuration).privacyIdeaAdministrationControllerRequiresTwoFactorAuthentication(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApi
     */
    public privacyIdeaAdministrationControllerResetToken(personId: string, options?: AxiosRequestConfig) {
        return Class2FAApiFp(this.configuration).privacyIdeaAdministrationControllerResetToken(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenVerifyBodyParams} tokenVerifyBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAApi
     */
    public privacyIdeaAdministrationControllerVerifyToken(tokenVerifyBodyParams: TokenVerifyBodyParams, options?: AxiosRequestConfig) {
        return Class2FAApiFp(this.configuration).privacyIdeaAdministrationControllerVerifyToken(tokenVerifyBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DbiamPersonenkontexteApi - axios parameter creator
 * @export
 */
export const DbiamPersonenkontexteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DbiamPersonenkontextMigrationBodyParams} dbiamPersonenkontextMigrationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerCreatePersonenkontextMigration: async (dbiamPersonenkontextMigrationBodyParams: DbiamPersonenkontextMigrationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbiamPersonenkontextMigrationBodyParams' is not null or undefined
            assertParamExists('dBiamPersonenkontextControllerCreatePersonenkontextMigration', 'dbiamPersonenkontextMigrationBodyParams', dbiamPersonenkontextMigrationBodyParams)
            const localVarPath = `/api/dbiam/personenkontext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbiamPersonenkontextMigrationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerFindPersonenkontextsByPerson: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('dBiamPersonenkontextControllerFindPersonenkontextsByPerson', 'personId', personId)
            const localVarPath = `/api/dbiam/personenkontext/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DbiamPersonenkontexteApi - functional programming interface
 * @export
 */
export const DbiamPersonenkontexteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DbiamPersonenkontexteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DbiamPersonenkontextMigrationBodyParams} dbiamPersonenkontextMigrationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenkontextControllerCreatePersonenkontextMigration(dbiamPersonenkontextMigrationBodyParams: DbiamPersonenkontextMigrationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBiamPersonenkontextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenkontextControllerCreatePersonenkontextMigration(dbiamPersonenkontextMigrationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DBiamPersonenkontextResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DbiamPersonenkontexteApi - factory interface
 * @export
 */
export const DbiamPersonenkontexteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DbiamPersonenkontexteApiFp(configuration)
    return {
        /**
         * 
         * @param {DbiamPersonenkontextMigrationBodyParams} dbiamPersonenkontextMigrationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerCreatePersonenkontextMigration(dbiamPersonenkontextMigrationBodyParams: DbiamPersonenkontextMigrationBodyParams, options?: any): AxiosPromise<DBiamPersonenkontextResponse> {
            return localVarFp.dBiamPersonenkontextControllerCreatePersonenkontextMigration(dbiamPersonenkontextMigrationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: any): AxiosPromise<Array<DBiamPersonenkontextResponse>> {
            return localVarFp.dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DbiamPersonenkontexteApi - interface
 * @export
 * @interface DbiamPersonenkontexteApi
 */
export interface DbiamPersonenkontexteApiInterface {
    /**
     * 
     * @param {DbiamPersonenkontextMigrationBodyParams} dbiamPersonenkontextMigrationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApiInterface
     */
    dBiamPersonenkontextControllerCreatePersonenkontextMigration(dbiamPersonenkontextMigrationBodyParams: DbiamPersonenkontextMigrationBodyParams, options?: AxiosRequestConfig): AxiosPromise<DBiamPersonenkontextResponse>;

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApiInterface
     */
    dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: AxiosRequestConfig): AxiosPromise<Array<DBiamPersonenkontextResponse>>;

}

/**
 * DbiamPersonenkontexteApi - object-oriented interface
 * @export
 * @class DbiamPersonenkontexteApi
 * @extends {BaseAPI}
 */
export class DbiamPersonenkontexteApi extends BaseAPI implements DbiamPersonenkontexteApiInterface {
    /**
     * 
     * @param {DbiamPersonenkontextMigrationBodyParams} dbiamPersonenkontextMigrationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApi
     */
    public dBiamPersonenkontextControllerCreatePersonenkontextMigration(dbiamPersonenkontextMigrationBodyParams: DbiamPersonenkontextMigrationBodyParams, options?: AxiosRequestConfig) {
        return DbiamPersonenkontexteApiFp(this.configuration).dBiamPersonenkontextControllerCreatePersonenkontextMigration(dbiamPersonenkontextMigrationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApi
     */
    public dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: AxiosRequestConfig) {
        return DbiamPersonenkontexteApiFp(this.configuration).dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DbiamPersonenuebersichtApi - axios parameter creator
 * @export
 */
export const DbiamPersonenuebersichtApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PersonenuebersichtBodyParams} personenuebersichtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichten: async (personenuebersichtBodyParams: PersonenuebersichtBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personenuebersichtBodyParams' is not null or undefined
            assertParamExists('dBiamPersonenuebersichtControllerFindPersonenuebersichten', 'personenuebersichtBodyParams', personenuebersichtBodyParams)
            const localVarPath = `/api/dbiam/personenuebersicht`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personenuebersichtBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson', 'personId', personId)
            const localVarPath = `/api/dbiam/personenuebersicht/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DbiamPersonenuebersichtApi - functional programming interface
 * @export
 */
export const DbiamPersonenuebersichtApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DbiamPersonenuebersichtApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PersonenuebersichtBodyParams} personenuebersichtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenuebersichtControllerFindPersonenuebersichten(personenuebersichtBodyParams: PersonenuebersichtBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenuebersichtControllerFindPersonenuebersichten(personenuebersichtBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBiamPersonenuebersichtResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DbiamPersonenuebersichtApi - factory interface
 * @export
 */
export const DbiamPersonenuebersichtApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DbiamPersonenuebersichtApiFp(configuration)
    return {
        /**
         * 
         * @param {PersonenuebersichtBodyParams} personenuebersichtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichten(personenuebersichtBodyParams: PersonenuebersichtBodyParams, options?: any): AxiosPromise<DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response> {
            return localVarFp.dBiamPersonenuebersichtControllerFindPersonenuebersichten(personenuebersichtBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: any): AxiosPromise<DBiamPersonenuebersichtResponse> {
            return localVarFp.dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DbiamPersonenuebersichtApi - interface
 * @export
 * @interface DbiamPersonenuebersichtApi
 */
export interface DbiamPersonenuebersichtApiInterface {
    /**
     * 
     * @param {PersonenuebersichtBodyParams} personenuebersichtBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApiInterface
     */
    dBiamPersonenuebersichtControllerFindPersonenuebersichten(personenuebersichtBodyParams: PersonenuebersichtBodyParams, options?: AxiosRequestConfig): AxiosPromise<DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response>;

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApiInterface
     */
    dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: AxiosRequestConfig): AxiosPromise<DBiamPersonenuebersichtResponse>;

}

/**
 * DbiamPersonenuebersichtApi - object-oriented interface
 * @export
 * @class DbiamPersonenuebersichtApi
 * @extends {BaseAPI}
 */
export class DbiamPersonenuebersichtApi extends BaseAPI implements DbiamPersonenuebersichtApiInterface {
    /**
     * 
     * @param {PersonenuebersichtBodyParams} personenuebersichtBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApi
     */
    public dBiamPersonenuebersichtControllerFindPersonenuebersichten(personenuebersichtBodyParams: PersonenuebersichtBodyParams, options?: AxiosRequestConfig) {
        return DbiamPersonenuebersichtApiFp(this.configuration).dBiamPersonenuebersichtControllerFindPersonenuebersichten(personenuebersichtBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApi
     */
    public dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: AxiosRequestConfig) {
        return DbiamPersonenuebersichtApiFp(this.configuration).dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganisationenApi - axios parameter creator
 * @export
 */
export const OrganisationenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddAdministrierteOrganisation: async (organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerAddAdministrierteOrganisation', 'organisationId', organisationId)
            // verify required parameter 'organisationByIdBodyParams' is not null or undefined
            assertParamExists('organisationControllerAddAdministrierteOrganisation', 'organisationByIdBodyParams', organisationByIdBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}/administriert`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationByIdBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddZugehoerigeOrganisation: async (organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerAddZugehoerigeOrganisation', 'organisationId', organisationId)
            // verify required parameter 'organisationByIdBodyParams' is not null or undefined
            assertParamExists('organisationControllerAddZugehoerigeOrganisation', 'organisationByIdBodyParams', organisationByIdBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}/zugehoerig`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationByIdBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerCreateOrganisation: async (createOrganisationBodyParams: CreateOrganisationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganisationBodyParams' is not null or undefined
            assertParamExists('organisationControllerCreateOrganisation', 'createOrganisationBodyParams', createOrganisationBodyParams)
            const localVarPath = `/api/organisationen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganisationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an organisation of type Klasse by id.
         * @summary 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerDeleteKlasse: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerDeleteKlasse', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}/klasse`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganisationById: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerFindOrganisationById', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {string} [searchString] 
         * @param {OrganisationsTyp} [typ] 
         * @param {Array<RollenSystemRecht>} [systemrechte] 
         * @param {Array<OrganisationsTyp>} [excludeTyp] 
         * @param {Array<string>} [administriertVon] 
         * @param {Array<string>} [organisationIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganizations: async (offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, excludeTyp?: Array<OrganisationsTyp>, administriertVon?: Array<string>, organisationIds?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organisationen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (kennung !== undefined) {
                localVarQueryParameter['kennung'] = kennung;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }

            if (typ !== undefined) {
                localVarQueryParameter['typ'] = typ;
            }

            if (systemrechte) {
                localVarQueryParameter['systemrechte'] = systemrechte;
            }

            if (excludeTyp) {
                localVarQueryParameter['excludeTyp'] = excludeTyp;
            }

            if (administriertVon) {
                localVarQueryParameter['administriertVon'] = administriertVon;
            }

            if (organisationIds) {
                localVarQueryParameter['organisationIds'] = organisationIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [searchFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetAdministrierteOrganisationen: async (organisationId: string, offset?: number, limit?: number, searchFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerGetAdministrierteOrganisationen', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}/administriert`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchFilter !== undefined) {
                localVarQueryParameter['searchFilter'] = searchFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParentOrganisationsByIdsBodyParams} parentOrganisationsByIdsBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetParentsByIds: async (parentOrganisationsByIdsBodyParams: ParentOrganisationsByIdsBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentOrganisationsByIdsBodyParams' is not null or undefined
            assertParamExists('organisationControllerGetParentsByIds', 'parentOrganisationsByIdsBodyParams', parentOrganisationsByIdsBodyParams)
            const localVarPath = `/api/organisationen/parents-by-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parentOrganisationsByIdsBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootChildren: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organisationen/root/children`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootOrganisation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organisationen/root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetZugehoerigeOrganisationen: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerGetZugehoerigeOrganisationen', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}/zugehoerig`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisation: async (organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisation', 'organisationId', organisationId)
            // verify required parameter 'updateOrganisationBodyParams' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisation', 'updateOrganisationBodyParams', updateOrganisationBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganisationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByNameBodyParams} organisationByNameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisationName: async (organisationId: string, organisationByNameBodyParams: OrganisationByNameBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisationName', 'organisationId', organisationId)
            // verify required parameter 'organisationByNameBodyParams' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisationName', 'organisationByNameBodyParams', organisationByNameBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}/name`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationByNameBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationenApi - functional programming interface
 * @export
 */
export const OrganisationenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerCreateOrganisation(createOrganisationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an organisation of type Klasse by id.
         * @summary 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerDeleteKlasse(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerDeleteKlasse(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerFindOrganisationById(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {string} [searchString] 
         * @param {OrganisationsTyp} [typ] 
         * @param {Array<RollenSystemRecht>} [systemrechte] 
         * @param {Array<OrganisationsTyp>} [excludeTyp] 
         * @param {Array<string>} [administriertVon] 
         * @param {Array<string>} [organisationIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, excludeTyp?: Array<OrganisationsTyp>, administriertVon?: Array<string>, organisationIds?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerFindOrganizations(offset, limit, kennung, name, searchString, typ, systemrechte, excludeTyp, administriertVon, organisationIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [searchFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetAdministrierteOrganisationen(organisationId: string, offset?: number, limit?: number, searchFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetAdministrierteOrganisationen(organisationId, offset, limit, searchFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ParentOrganisationsByIdsBodyParams} parentOrganisationsByIdsBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetParentsByIds(parentOrganisationsByIdsBodyParams: ParentOrganisationsByIdsBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParentOrganisationenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetParentsByIds(parentOrganisationsByIdsBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetRootChildren(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationRootChildrenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetRootChildren(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetRootOrganisation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetRootOrganisation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetZugehoerigeOrganisationen(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByNameBodyParams} organisationByNameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerUpdateOrganisationName(organisationId: string, organisationByNameBodyParams: OrganisationByNameBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponseLegacy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerUpdateOrganisationName(organisationId, organisationByNameBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganisationenApi - factory interface
 * @export
 */
export const OrganisationenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationenApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerCreateOrganisation(createOrganisationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an organisation of type Klasse by id.
         * @summary 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerDeleteKlasse(organisationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationControllerDeleteKlasse(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganisationById(organisationId: string, options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerFindOrganisationById(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {string} [searchString] 
         * @param {OrganisationsTyp} [typ] 
         * @param {Array<RollenSystemRecht>} [systemrechte] 
         * @param {Array<OrganisationsTyp>} [excludeTyp] 
         * @param {Array<string>} [administriertVon] 
         * @param {Array<string>} [organisationIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, excludeTyp?: Array<OrganisationsTyp>, administriertVon?: Array<string>, organisationIds?: Array<string>, options?: any): AxiosPromise<Array<OrganisationResponse>> {
            return localVarFp.organisationControllerFindOrganizations(offset, limit, kennung, name, searchString, typ, systemrechte, excludeTyp, administriertVon, organisationIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [searchFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetAdministrierteOrganisationen(organisationId: string, offset?: number, limit?: number, searchFilter?: string, options?: any): AxiosPromise<Array<OrganisationResponse>> {
            return localVarFp.organisationControllerGetAdministrierteOrganisationen(organisationId, offset, limit, searchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ParentOrganisationsByIdsBodyParams} parentOrganisationsByIdsBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetParentsByIds(parentOrganisationsByIdsBodyParams: ParentOrganisationsByIdsBodyParams, options?: any): AxiosPromise<ParentOrganisationenResponse> {
            return localVarFp.organisationControllerGetParentsByIds(parentOrganisationsByIdsBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootChildren(options?: any): AxiosPromise<OrganisationRootChildrenResponse> {
            return localVarFp.organisationControllerGetRootChildren(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootOrganisation(options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerGetRootOrganisation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: any): AxiosPromise<Array<OrganisationResponse>> {
            return localVarFp.organisationControllerGetZugehoerigeOrganisationen(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: any): AxiosPromise<OrganisationResponse> {
            return localVarFp.organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByNameBodyParams} organisationByNameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisationName(organisationId: string, organisationByNameBodyParams: OrganisationByNameBodyParams, options?: any): AxiosPromise<OrganisationResponseLegacy> {
            return localVarFp.organisationControllerUpdateOrganisationName(organisationId, organisationByNameBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationenApi - interface
 * @export
 * @interface OrganisationenApi
 */
export interface OrganisationenApiInterface {
    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

    /**
     * Delete an organisation of type Klasse by id.
     * @summary 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerDeleteKlasse(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [kennung] 
     * @param {string} [name] 
     * @param {string} [searchString] 
     * @param {OrganisationsTyp} [typ] 
     * @param {Array<RollenSystemRecht>} [systemrechte] 
     * @param {Array<OrganisationsTyp>} [excludeTyp] 
     * @param {Array<string>} [administriertVon] 
     * @param {Array<string>} [organisationIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, excludeTyp?: Array<OrganisationsTyp>, administriertVon?: Array<string>, organisationIds?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponse>>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [searchFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetAdministrierteOrganisationen(organisationId: string, offset?: number, limit?: number, searchFilter?: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponse>>;

    /**
     * 
     * @param {ParentOrganisationsByIdsBodyParams} parentOrganisationsByIdsBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetParentsByIds(parentOrganisationsByIdsBodyParams: ParentOrganisationsByIdsBodyParams, options?: AxiosRequestConfig): AxiosPromise<ParentOrganisationenResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetRootChildren(options?: AxiosRequestConfig): AxiosPromise<OrganisationRootChildrenResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetRootOrganisation(options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponse>>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponse>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByNameBodyParams} organisationByNameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerUpdateOrganisationName(organisationId: string, organisationByNameBodyParams: OrganisationByNameBodyParams, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponseLegacy>;

}

/**
 * OrganisationenApi - object-oriented interface
 * @export
 * @class OrganisationenApi
 * @extends {BaseAPI}
 */
export class OrganisationenApi extends BaseAPI implements OrganisationenApiInterface {
    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerCreateOrganisation(createOrganisationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an organisation of type Klasse by id.
     * @summary 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerDeleteKlasse(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerDeleteKlasse(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerFindOrganisationById(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [kennung] 
     * @param {string} [name] 
     * @param {string} [searchString] 
     * @param {OrganisationsTyp} [typ] 
     * @param {Array<RollenSystemRecht>} [systemrechte] 
     * @param {Array<OrganisationsTyp>} [excludeTyp] 
     * @param {Array<string>} [administriertVon] 
     * @param {Array<string>} [organisationIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, excludeTyp?: Array<OrganisationsTyp>, administriertVon?: Array<string>, organisationIds?: Array<string>, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerFindOrganizations(offset, limit, kennung, name, searchString, typ, systemrechte, excludeTyp, administriertVon, organisationIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [searchFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetAdministrierteOrganisationen(organisationId: string, offset?: number, limit?: number, searchFilter?: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetAdministrierteOrganisationen(organisationId, offset, limit, searchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ParentOrganisationsByIdsBodyParams} parentOrganisationsByIdsBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetParentsByIds(parentOrganisationsByIdsBodyParams: ParentOrganisationsByIdsBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetParentsByIds(parentOrganisationsByIdsBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetRootChildren(options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetRootChildren(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetRootOrganisation(options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetRootOrganisation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetZugehoerigeOrganisationen(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByNameBodyParams} organisationByNameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerUpdateOrganisationName(organisationId: string, organisationByNameBodyParams: OrganisationByNameBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerUpdateOrganisationName(organisationId, organisationByNameBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonAdministrationApi - axios parameter creator
 * @export
 */
export const PersonAdministrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personAdministrationControllerFindRollen: async (rolleName?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/person-administration/rollen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (rolleName !== undefined) {
                localVarQueryParameter['rolleName'] = rolleName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonAdministrationApi - functional programming interface
 * @export
 */
export const PersonAdministrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonAdministrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personAdministrationControllerFindRollen(rolleName?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindRollenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personAdministrationControllerFindRollen(rolleName, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonAdministrationApi - factory interface
 * @export
 */
export const PersonAdministrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonAdministrationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personAdministrationControllerFindRollen(rolleName?: string, limit?: number, options?: any): AxiosPromise<FindRollenResponse> {
            return localVarFp.personAdministrationControllerFindRollen(rolleName, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonAdministrationApi - interface
 * @export
 * @interface PersonAdministrationApi
 */
export interface PersonAdministrationApiInterface {
    /**
     * 
     * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonAdministrationApiInterface
     */
    personAdministrationControllerFindRollen(rolleName?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<FindRollenResponse>;

}

/**
 * PersonAdministrationApi - object-oriented interface
 * @export
 * @class PersonAdministrationApi
 * @extends {BaseAPI}
 */
export class PersonAdministrationApi extends BaseAPI implements PersonAdministrationApiInterface {
    /**
     * 
     * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonAdministrationApi
     */
    public personAdministrationControllerFindRollen(rolleName?: string, limit?: number, options?: AxiosRequestConfig) {
        return PersonAdministrationApiFp(this.configuration).personAdministrationControllerFindRollen(rolleName, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonInfoApi - axios parameter creator
 * @export
 */
export const PersonInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Info about logged in person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personInfoControllerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/person-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonInfoApi - functional programming interface
 * @export
 */
export const PersonInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Info about logged in person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personInfoControllerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personInfoControllerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonInfoApi - factory interface
 * @export
 */
export const PersonInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Info about logged in person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personInfoControllerInfo(options?: any): AxiosPromise<PersonInfoResponse> {
            return localVarFp.personInfoControllerInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonInfoApi - interface
 * @export
 * @interface PersonInfoApi
 */
export interface PersonInfoApiInterface {
    /**
     * 
     * @summary Info about logged in person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonInfoApiInterface
     */
    personInfoControllerInfo(options?: AxiosRequestConfig): AxiosPromise<PersonInfoResponse>;

}

/**
 * PersonInfoApi - object-oriented interface
 * @export
 * @class PersonInfoApi
 * @extends {BaseAPI}
 */
export class PersonInfoApi extends BaseAPI implements PersonInfoApiInterface {
    /**
     * 
     * @summary Info about logged in person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonInfoApi
     */
    public personInfoControllerInfo(options?: AxiosRequestConfig) {
        return PersonInfoApiFp(this.configuration).personInfoControllerInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenApi - axios parameter creator
 * @export
 */
export const PersonenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePersonMigrationBodyParams} createPersonMigrationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePersonMigration: async (createPersonMigrationBodyParams: CreatePersonMigrationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonMigrationBodyParams' is not null or undefined
            assertParamExists('personControllerCreatePersonMigration', 'createPersonMigrationBodyParams', createPersonMigrationBodyParams)
            const localVarPath = `/api/personen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonMigrationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        personControllerCreatePersonenkontext: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerCreatePersonenkontext', 'personId', personId)
            const localVarPath = `/api/personen/{personId}/personenkontexte`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerDeletePersonById: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerDeletePersonById', 'personId', personId)
            const localVarPath = `/api/personen/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonById: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerFindPersonById', 'personId', personId)
            const localVarPath = `/api/personen/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [personId2] 
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonenkontexte: async (personId: string, offset?: number, limit?: number, personId2?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerFindPersonenkontexte', 'personId', personId)
            const localVarPath = `/api/personen/{personId}/personenkontexte`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (personId2 !== undefined) {
                localVarQueryParameter['personId'] = personId2;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (rolle !== undefined) {
                localVarQueryParameter['rolle'] = rolle;
            }

            if (personenstatus !== undefined) {
                localVarQueryParameter['personenstatus'] = personenstatus;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
         * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersons: async (offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (familienname !== undefined) {
                localVarQueryParameter['familienname'] = familienname;
            }

            if (vorname !== undefined) {
                localVarQueryParameter['vorname'] = vorname;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }

            if (organisationIDs) {
                localVarQueryParameter['organisationIDs'] = organisationIDs;
            }

            if (rolleIDs) {
                localVarQueryParameter['rolleIDs'] = rolleIDs;
            }

            if (suchFilter !== undefined) {
                localVarQueryParameter['suchFilter'] = suchFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId 
         * @param {LockUserBodyParams} lockUserBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerLockPerson: async (personId: string, lockUserBodyParams: LockUserBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerLockPerson', 'personId', personId)
            // verify required parameter 'lockUserBodyParams' is not null or undefined
            assertParamExists('personControllerLockPerson', 'lockUserBodyParams', lockUserBodyParams)
            const localVarPath = `/api/personen/{personId}/lock-user`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lockUserBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerResetPasswordByPersonId: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerResetPasswordByPersonId', 'personId', personId)
            const localVarPath = `/api/personen/{personId}/password`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePerson: async (personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerUpdatePerson', 'personId', personId)
            // verify required parameter 'updatePersonBodyParams' is not null or undefined
            assertParamExists('personControllerUpdatePerson', 'updatePersonBodyParams', updatePersonBodyParams)
            const localVarPath = `/api/personen/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {PersonByPersonalnummerBodyParams} personByPersonalnummerBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePersonalnummer: async (personId: string, personByPersonalnummerBodyParams: PersonByPersonalnummerBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerUpdatePersonalnummer', 'personId', personId)
            // verify required parameter 'personByPersonalnummerBodyParams' is not null or undefined
            assertParamExists('personControllerUpdatePersonalnummer', 'personByPersonalnummerBodyParams', personByPersonalnummerBodyParams)
            const localVarPath = `/api/personen/{personId}/personalnummer`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personByPersonalnummerBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenApi - functional programming interface
 * @export
 */
export const PersonenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePersonMigrationBodyParams} createPersonMigrationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerCreatePersonMigration(createPersonMigrationBodyParams: CreatePersonMigrationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerCreatePersonMigration(createPersonMigrationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async personControllerCreatePersonenkontext(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerCreatePersonenkontext(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerDeletePersonById(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerDeletePersonById(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersonById(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersonById(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [personId2] 
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, personId2?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonControllerFindPersonenkontexte200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersonenkontexte(personId, offset, limit, personId2, referrer, rolle, personenstatus, sichtfreigabe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
         * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonendatensatzResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, organisationIDs, rolleIDs, suchFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId 
         * @param {LockUserBodyParams} lockUserBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerLockPerson(personId: string, lockUserBodyParams: LockUserBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonLockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerLockPerson(personId, lockUserBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerResetPasswordByPersonId(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerUpdatePerson(personId, updatePersonBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {PersonByPersonalnummerBodyParams} personByPersonalnummerBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerUpdatePersonalnummer(personId: string, personByPersonalnummerBodyParams: PersonByPersonalnummerBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerUpdatePersonalnummer(personId, personByPersonalnummerBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenApi - factory interface
 * @export
 */
export const PersonenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePersonMigrationBodyParams} createPersonMigrationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePersonMigration(createPersonMigrationBodyParams: CreatePersonMigrationBodyParams, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerCreatePersonMigration(createPersonMigrationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} personId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        personControllerCreatePersonenkontext(personId: string, options?: any): AxiosPromise<void> {
            return localVarFp.personControllerCreatePersonenkontext(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerDeletePersonById(personId: string, options?: any): AxiosPromise<void> {
            return localVarFp.personControllerDeletePersonById(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonById(personId: string, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerFindPersonById(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [personId2] 
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, personId2?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: any): AxiosPromise<PersonControllerFindPersonenkontexte200Response> {
            return localVarFp.personControllerFindPersonenkontexte(personId, offset, limit, personId2, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
         * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: any): AxiosPromise<Array<PersonendatensatzResponse>> {
            return localVarFp.personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, organisationIDs, rolleIDs, suchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId 
         * @param {LockUserBodyParams} lockUserBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerLockPerson(personId: string, lockUserBodyParams: LockUserBodyParams, options?: any): AxiosPromise<PersonLockResponse> {
            return localVarFp.personControllerLockPerson(personId, lockUserBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerResetPasswordByPersonId(personId: string, options?: any): AxiosPromise<string> {
            return localVarFp.personControllerResetPasswordByPersonId(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerUpdatePerson(personId, updatePersonBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {PersonByPersonalnummerBodyParams} personByPersonalnummerBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePersonalnummer(personId: string, personByPersonalnummerBodyParams: PersonByPersonalnummerBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.personControllerUpdatePersonalnummer(personId, personByPersonalnummerBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenApi - interface
 * @export
 * @interface PersonenApi
 */
export interface PersonenApiInterface {
    /**
     * 
     * @param {CreatePersonMigrationBodyParams} createPersonMigrationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerCreatePersonMigration(createPersonMigrationBodyParams: CreatePersonMigrationBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

    /**
     * 
     * @summary 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerCreatePersonenkontext(personId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerDeletePersonById(personId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersonById(personId: string, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [personId2] 
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, personId2?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): AxiosPromise<PersonControllerFindPersonenkontexte200Response>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
     * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: AxiosRequestConfig): AxiosPromise<Array<PersonendatensatzResponse>>;

    /**
     * 
     * @param {string} personId 
     * @param {LockUserBodyParams} lockUserBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerLockPerson(personId: string, lockUserBodyParams: LockUserBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonLockResponse>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {UpdatePersonBodyParams} updatePersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {PersonByPersonalnummerBodyParams} personByPersonalnummerBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerUpdatePersonalnummer(personId: string, personByPersonalnummerBodyParams: PersonByPersonalnummerBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * PersonenApi - object-oriented interface
 * @export
 * @class PersonenApi
 * @extends {BaseAPI}
 */
export class PersonenApi extends BaseAPI implements PersonenApiInterface {
    /**
     * 
     * @param {CreatePersonMigrationBodyParams} createPersonMigrationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerCreatePersonMigration(createPersonMigrationBodyParams: CreatePersonMigrationBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerCreatePersonMigration(createPersonMigrationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} personId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerCreatePersonenkontext(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerCreatePersonenkontext(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerDeletePersonById(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerDeletePersonById(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersonById(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersonById(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [personId2] 
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, personId2?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersonenkontexte(personId, offset, limit, personId2, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
     * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, organisationIDs, rolleIDs, suchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId 
     * @param {LockUserBodyParams} lockUserBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerLockPerson(personId: string, lockUserBodyParams: LockUserBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerLockPerson(personId, lockUserBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerResetPasswordByPersonId(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {UpdatePersonBodyParams} updatePersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerUpdatePerson(personId, updatePersonBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {PersonByPersonalnummerBodyParams} personByPersonalnummerBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerUpdatePersonalnummer(personId: string, personByPersonalnummerBodyParams: PersonByPersonalnummerBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerUpdatePersonalnummer(personId, personByPersonalnummerBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenFrontendApi - axios parameter creator
 * @export
 */
export const PersonenFrontendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
         * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personFrontendControllerFindPersons: async (offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personen-frontend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (familienname !== undefined) {
                localVarQueryParameter['familienname'] = familienname;
            }

            if (vorname !== undefined) {
                localVarQueryParameter['vorname'] = vorname;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }

            if (organisationIDs) {
                localVarQueryParameter['organisationIDs'] = organisationIDs;
            }

            if (rolleIDs) {
                localVarQueryParameter['rolleIDs'] = rolleIDs;
            }

            if (suchFilter !== undefined) {
                localVarQueryParameter['suchFilter'] = suchFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenFrontendApi - functional programming interface
 * @export
 */
export const PersonenFrontendApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenFrontendApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
         * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonFrontendControllerFindPersons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, organisationIDs, rolleIDs, suchFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenFrontendApi - factory interface
 * @export
 */
export const PersonenFrontendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenFrontendApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
         * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: any): AxiosPromise<PersonFrontendControllerFindPersons200Response> {
            return localVarFp.personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, organisationIDs, rolleIDs, suchFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenFrontendApi - interface
 * @export
 * @interface PersonenFrontendApi
 */
export interface PersonenFrontendApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
     * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenFrontendApiInterface
     */
    personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: AxiosRequestConfig): AxiosPromise<PersonFrontendControllerFindPersons200Response>;

}

/**
 * PersonenFrontendApi - object-oriented interface
 * @export
 * @class PersonenFrontendApi
 * @extends {BaseAPI}
 */
export class PersonenFrontendApi extends BaseAPI implements PersonenFrontendApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {Array<string>} [organisationIDs] List of Organisation ID used to filter for Persons.
     * @param {Array<string>} [rolleIDs] List of Role ID used to filter for Persons.
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenFrontendApi
     */
    public personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', organisationIDs?: Array<string>, rolleIDs?: Array<string>, suchFilter?: string, options?: AxiosRequestConfig) {
        return PersonenFrontendApiFp(this.configuration).personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, organisationIDs, rolleIDs, suchFilter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenkontextApi - axios parameter creator
 * @export
 */
export const PersonenkontextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {DbiamUpdatePersonenkontexteBodyParams} dbiamUpdatePersonenkontexteBodyParams 
         * @param {string} [personalnummer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerCommit: async (personId: string, dbiamUpdatePersonenkontexteBodyParams: DbiamUpdatePersonenkontexteBodyParams, personalnummer?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('dbiamPersonenkontextWorkflowControllerCommit', 'personId', personId)
            // verify required parameter 'dbiamUpdatePersonenkontexteBodyParams' is not null or undefined
            assertParamExists('dbiamPersonenkontextWorkflowControllerCommit', 'dbiamUpdatePersonenkontexteBodyParams', dbiamUpdatePersonenkontexteBodyParams)
            const localVarPath = `/api/personenkontext-workflow/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (personalnummer !== undefined) {
                localVarQueryParameter['personalnummer'] = personalnummer;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbiamUpdatePersonenkontexteBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DbiamCreatePersonWithPersonenkontexteBodyParams} dbiamCreatePersonWithPersonenkontexteBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte: async (dbiamCreatePersonWithPersonenkontexteBodyParams: DbiamCreatePersonWithPersonenkontexteBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbiamCreatePersonWithPersonenkontexteBodyParams' is not null or undefined
            assertParamExists('dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte', 'dbiamCreatePersonWithPersonenkontexteBodyParams', dbiamCreatePersonWithPersonenkontexteBodyParams)
            const localVarPath = `/api/personenkontext-workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbiamCreatePersonWithPersonenkontexteBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
         * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten: async (rolleId: string, sskName?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten', 'rolleId', rolleId)
            const localVarPath = `/api/personenkontext-workflow/schulstrukturknoten`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (rolleId !== undefined) {
                localVarQueryParameter['rolleId'] = rolleId;
            }

            if (sskName !== undefined) {
                localVarQueryParameter['sskName'] = sskName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [organisationId] ID of the organisation to filter the rollen later
         * @param {string} [rolleId] ID of the rolle.
         * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
         * @param {string} [organisationName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerProcessStep: async (organisationId?: string, rolleId?: string, rolleName?: string, organisationName?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personenkontext-workflow/step`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (organisationId !== undefined) {
                localVarQueryParameter['organisationId'] = organisationId;
            }

            if (rolleId !== undefined) {
                localVarQueryParameter['rolleId'] = rolleId;
            }

            if (rolleName !== undefined) {
                localVarQueryParameter['rolleName'] = rolleName;
            }

            if (organisationName !== undefined) {
                localVarQueryParameter['organisationName'] = organisationName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenkontextApi - functional programming interface
 * @export
 */
export const PersonenkontextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenkontextApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {DbiamUpdatePersonenkontexteBodyParams} dbiamUpdatePersonenkontexteBodyParams 
         * @param {string} [personalnummer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dbiamPersonenkontextWorkflowControllerCommit(personId: string, dbiamUpdatePersonenkontexteBodyParams: DbiamUpdatePersonenkontexteBodyParams, personalnummer?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonenkontexteUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dbiamPersonenkontextWorkflowControllerCommit(personId, dbiamUpdatePersonenkontexteBodyParams, personalnummer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DbiamCreatePersonWithPersonenkontexteBodyParams} dbiamCreatePersonWithPersonenkontexteBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte(dbiamCreatePersonWithPersonenkontexteBodyParams: DbiamCreatePersonWithPersonenkontexteBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBiamPersonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte(dbiamCreatePersonWithPersonenkontexteBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
         * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindSchulstrukturknotenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten(rolleId, sskName, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [organisationId] ID of the organisation to filter the rollen later
         * @param {string} [rolleId] ID of the rolle.
         * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
         * @param {string} [organisationName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dbiamPersonenkontextWorkflowControllerProcessStep(organisationId?: string, rolleId?: string, rolleName?: string, organisationName?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonenkontextWorkflowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dbiamPersonenkontextWorkflowControllerProcessStep(organisationId, rolleId, rolleName, organisationName, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenkontextApi - factory interface
 * @export
 */
export const PersonenkontextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenkontextApiFp(configuration)
    return {
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {DbiamUpdatePersonenkontexteBodyParams} dbiamUpdatePersonenkontexteBodyParams 
         * @param {string} [personalnummer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerCommit(personId: string, dbiamUpdatePersonenkontexteBodyParams: DbiamUpdatePersonenkontexteBodyParams, personalnummer?: string, options?: any): AxiosPromise<PersonenkontexteUpdateResponse> {
            return localVarFp.dbiamPersonenkontextWorkflowControllerCommit(personId, dbiamUpdatePersonenkontexteBodyParams, personalnummer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DbiamCreatePersonWithPersonenkontexteBodyParams} dbiamCreatePersonWithPersonenkontexteBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte(dbiamCreatePersonWithPersonenkontexteBodyParams: DbiamCreatePersonWithPersonenkontexteBodyParams, options?: any): AxiosPromise<DBiamPersonResponse> {
            return localVarFp.dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte(dbiamCreatePersonWithPersonenkontexteBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
         * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: any): AxiosPromise<FindSchulstrukturknotenResponse> {
            return localVarFp.dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten(rolleId, sskName, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [organisationId] ID of the organisation to filter the rollen later
         * @param {string} [rolleId] ID of the rolle.
         * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
         * @param {string} [organisationName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextWorkflowControllerProcessStep(organisationId?: string, rolleId?: string, rolleName?: string, organisationName?: string, limit?: number, options?: any): AxiosPromise<PersonenkontextWorkflowResponse> {
            return localVarFp.dbiamPersonenkontextWorkflowControllerProcessStep(organisationId, rolleId, rolleName, organisationName, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenkontextApi - interface
 * @export
 * @interface PersonenkontextApi
 */
export interface PersonenkontextApiInterface {
    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {DbiamUpdatePersonenkontexteBodyParams} dbiamUpdatePersonenkontexteBodyParams 
     * @param {string} [personalnummer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApiInterface
     */
    dbiamPersonenkontextWorkflowControllerCommit(personId: string, dbiamUpdatePersonenkontexteBodyParams: DbiamUpdatePersonenkontexteBodyParams, personalnummer?: string, options?: AxiosRequestConfig): AxiosPromise<PersonenkontexteUpdateResponse>;

    /**
     * 
     * @param {DbiamCreatePersonWithPersonenkontexteBodyParams} dbiamCreatePersonWithPersonenkontexteBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApiInterface
     */
    dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte(dbiamCreatePersonWithPersonenkontexteBodyParams: DbiamCreatePersonWithPersonenkontexteBodyParams, options?: AxiosRequestConfig): AxiosPromise<DBiamPersonResponse>;

    /**
     * 
     * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
     * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApiInterface
     */
    dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<FindSchulstrukturknotenResponse>;

    /**
     * 
     * @param {string} [organisationId] ID of the organisation to filter the rollen later
     * @param {string} [rolleId] ID of the rolle.
     * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
     * @param {string} [organisationName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApiInterface
     */
    dbiamPersonenkontextWorkflowControllerProcessStep(organisationId?: string, rolleId?: string, rolleName?: string, organisationName?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<PersonenkontextWorkflowResponse>;

}

/**
 * PersonenkontextApi - object-oriented interface
 * @export
 * @class PersonenkontextApi
 * @extends {BaseAPI}
 */
export class PersonenkontextApi extends BaseAPI implements PersonenkontextApiInterface {
    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {DbiamUpdatePersonenkontexteBodyParams} dbiamUpdatePersonenkontexteBodyParams 
     * @param {string} [personalnummer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApi
     */
    public dbiamPersonenkontextWorkflowControllerCommit(personId: string, dbiamUpdatePersonenkontexteBodyParams: DbiamUpdatePersonenkontexteBodyParams, personalnummer?: string, options?: AxiosRequestConfig) {
        return PersonenkontextApiFp(this.configuration).dbiamPersonenkontextWorkflowControllerCommit(personId, dbiamUpdatePersonenkontexteBodyParams, personalnummer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DbiamCreatePersonWithPersonenkontexteBodyParams} dbiamCreatePersonWithPersonenkontexteBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApi
     */
    public dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte(dbiamCreatePersonWithPersonenkontexteBodyParams: DbiamCreatePersonWithPersonenkontexteBodyParams, options?: AxiosRequestConfig) {
        return PersonenkontextApiFp(this.configuration).dbiamPersonenkontextWorkflowControllerCreatePersonWithPersonenkontexte(dbiamCreatePersonWithPersonenkontexteBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
     * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApi
     */
    public dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: AxiosRequestConfig) {
        return PersonenkontextApiFp(this.configuration).dbiamPersonenkontextWorkflowControllerFindSchulstrukturknoten(rolleId, sskName, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [organisationId] ID of the organisation to filter the rollen later
     * @param {string} [rolleId] ID of the rolle.
     * @param {string} [rolleName] Rolle name used to filter for rollen in personenkontext.
     * @param {string} [organisationName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApi
     */
    public dbiamPersonenkontextWorkflowControllerProcessStep(organisationId?: string, rolleId?: string, rolleName?: string, organisationName?: string, limit?: number, options?: AxiosRequestConfig) {
        return PersonenkontextApiFp(this.configuration).dbiamPersonenkontextWorkflowControllerProcessStep(organisationId, rolleId, rolleName, organisationName, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenkontexteApi - axios parameter creator
 * @export
 */
export const PersonenkontexteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerDeletePersonenkontextById: async (personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personenkontextId' is not null or undefined
            assertParamExists('personenkontextControllerDeletePersonenkontextById', 'personenkontextId', personenkontextId)
            // verify required parameter 'deleteRevisionBodyParams' is not null or undefined
            assertParamExists('personenkontextControllerDeletePersonenkontextById', 'deleteRevisionBodyParams', deleteRevisionBodyParams)
            const localVarPath = `/api/personenkontexte/{personenkontextId}`
                .replace(`{${"personenkontextId"}}`, encodeURIComponent(String(personenkontextId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRevisionBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontextById: async (personenkontextId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personenkontextId' is not null or undefined
            assertParamExists('personenkontextControllerFindPersonenkontextById', 'personenkontextId', personenkontextId)
            const localVarPath = `/api/personenkontexte/{personenkontextId}`
                .replace(`{${"personenkontextId"}}`, encodeURIComponent(String(personenkontextId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [personId] 
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontexte: async (offset?: number, limit?: number, personId?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personenkontexte`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (personId !== undefined) {
                localVarQueryParameter['personId'] = personId;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (rolle !== undefined) {
                localVarQueryParameter['rolle'] = rolle;
            }

            if (personenstatus !== undefined) {
                localVarQueryParameter['personenstatus'] = personenstatus;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {RollenSystemRecht} systemRecht 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerHatSystemRecht: async (personId: string, systemRecht: RollenSystemRecht, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personenkontextControllerHatSystemRecht', 'personId', personId)
            // verify required parameter 'systemRecht' is not null or undefined
            assertParamExists('personenkontextControllerHatSystemRecht', 'systemRecht', systemRecht)
            const localVarPath = `/api/personenkontexte/{personId}/hatSystemrecht`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (systemRecht !== undefined) {
                localVarQueryParameter['systemRecht'] = systemRecht;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} personenkontextId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        personenkontextControllerUpdatePersonenkontextWithId: async (personenkontextId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personenkontextId' is not null or undefined
            assertParamExists('personenkontextControllerUpdatePersonenkontextWithId', 'personenkontextId', personenkontextId)
            const localVarPath = `/api/personenkontexte/{personenkontextId}`
                .replace(`{${"personenkontextId"}}`, encodeURIComponent(String(personenkontextId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenkontexteApi - functional programming interface
 * @export
 */
export const PersonenkontexteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenkontexteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerDeletePersonenkontextById(personenkontextId, deleteRevisionBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponseAutomapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerFindPersonenkontextById(personenkontextId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [personId] 
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, personId?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonenkontextdatensatzResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerFindPersonenkontexte(offset, limit, personId, referrer, rolle, personenstatus, sichtfreigabe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {RollenSystemRecht} systemRecht 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemrechtResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerHatSystemRecht(personId, systemRecht, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} personenkontextId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonenkontextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerUpdatePersonenkontextWithId(personenkontextId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenkontexteApi - factory interface
 * @export
 */
export const PersonenkontexteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenkontexteApiFp(configuration)
    return {
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.personenkontextControllerDeletePersonenkontextById(personenkontextId, deleteRevisionBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: any): AxiosPromise<PersonendatensatzResponseAutomapper> {
            return localVarFp.personenkontextControllerFindPersonenkontextById(personenkontextId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [personId] 
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, personId?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: any): AxiosPromise<Array<PersonenkontextdatensatzResponse>> {
            return localVarFp.personenkontextControllerFindPersonenkontexte(offset, limit, personId, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {RollenSystemRecht} systemRecht 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: any): AxiosPromise<SystemrechtResponse> {
            return localVarFp.personenkontextControllerHatSystemRecht(personId, systemRecht, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} personenkontextId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, options?: any): AxiosPromise<PersonenkontextResponse> {
            return localVarFp.personenkontextControllerUpdatePersonenkontextWithId(personenkontextId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenkontexteApi - interface
 * @export
 * @interface PersonenkontexteApi
 */
export interface PersonenkontexteApiInterface {
    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponseAutomapper>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [personId] 
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, personId?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): AxiosPromise<Array<PersonenkontextdatensatzResponse>>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {RollenSystemRecht} systemRecht 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: AxiosRequestConfig): AxiosPromise<SystemrechtResponse>;

    /**
     * 
     * @summary 
     * @param {string} personenkontextId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, options?: AxiosRequestConfig): AxiosPromise<PersonenkontextResponse>;

}

/**
 * PersonenkontexteApi - object-oriented interface
 * @export
 * @class PersonenkontexteApi
 * @extends {BaseAPI}
 */
export class PersonenkontexteApi extends BaseAPI implements PersonenkontexteApiInterface {
    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerDeletePersonenkontextById(personenkontextId, deleteRevisionBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerFindPersonenkontextById(personenkontextId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [personId] 
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, personId?: string, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerFindPersonenkontexte(offset, limit, personId, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {RollenSystemRecht} systemRecht 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerHatSystemRecht(personId, systemRecht, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} personenkontextId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerUpdatePersonenkontextWithId(personenkontextId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProviderApi - axios parameter creator
 * @export
 */
export const ProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all service-providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAllServiceProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provider/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get service-providers available for logged-in user.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAvailableServiceProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProviderLogo: async (angebotId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'angebotId' is not null or undefined
            assertParamExists('providerControllerGetServiceProviderLogo', 'angebotId', angebotId)
            const localVarPath = `/api/provider/{angebotId}/logo`
                .replace(`{${"angebotId"}}`, encodeURIComponent(String(angebotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all service-providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetAllServiceProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceProviderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetAllServiceProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get service-providers available for logged-in user.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetAvailableServiceProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceProviderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetAvailableServiceProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetServiceProviderLogo(angebotId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderApiFp(configuration)
    return {
        /**
         * Get all service-providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAllServiceProviders(options?: any): AxiosPromise<Array<ServiceProviderResponse>> {
            return localVarFp.providerControllerGetAllServiceProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Get service-providers available for logged-in user.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAvailableServiceProviders(options?: any): AxiosPromise<Array<ServiceProviderResponse>> {
            return localVarFp.providerControllerGetAvailableServiceProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProviderLogo(angebotId: string, options?: any): AxiosPromise<any> {
            return localVarFp.providerControllerGetServiceProviderLogo(angebotId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderApi - interface
 * @export
 * @interface ProviderApi
 */
export interface ProviderApiInterface {
    /**
     * Get all service-providers.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetAllServiceProviders(options?: AxiosRequestConfig): AxiosPromise<Array<ServiceProviderResponse>>;

    /**
     * Get service-providers available for logged-in user.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetAvailableServiceProviders(options?: AxiosRequestConfig): AxiosPromise<Array<ServiceProviderResponse>>;

    /**
     * 
     * @param {string} angebotId The id of the service provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig): AxiosPromise<any>;

}

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI implements ProviderApiInterface {
    /**
     * Get all service-providers.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetAllServiceProviders(options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetAllServiceProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get service-providers available for logged-in user.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetAvailableServiceProviders(options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetAvailableServiceProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} angebotId The id of the service provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetServiceProviderLogo(angebotId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolleApi - axios parameter creator
 * @export
 */
export const RolleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a service-provider to a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {RolleServiceProviderBodyParams} rolleServiceProviderBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddServiceProviderById: async (rolleId: string, rolleServiceProviderBodyParams: RolleServiceProviderBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerAddServiceProviderById', 'rolleId', rolleId)
            // verify required parameter 'rolleServiceProviderBodyParams' is not null or undefined
            assertParamExists('rolleControllerAddServiceProviderById', 'rolleServiceProviderBodyParams', rolleServiceProviderBodyParams)
            const localVarPath = `/api/rolle/{rolleId}/serviceProviders`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolleServiceProviderBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add systemrecht to a rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddSystemRecht: async (rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerAddSystemRecht', 'rolleId', rolleId)
            // verify required parameter 'addSystemrechtBodyParams' is not null or undefined
            assertParamExists('rolleControllerAddSystemRecht', 'addSystemrechtBodyParams', addSystemrechtBodyParams)
            const localVarPath = `/api/rolle/{rolleId}`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addSystemrechtBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerCreateRolle: async (createRolleBodyParams: CreateRolleBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRolleBodyParams' is not null or undefined
            assertParamExists('rolleControllerCreateRolle', 'createRolleBodyParams', createRolleBodyParams)
            const localVarPath = `/api/rolle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRolleBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerDeleteRolle: async (rolleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerDeleteRolle', 'rolleId', rolleId)
            const localVarPath = `/api/rolle/{rolleId}`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRolleByIdWithServiceProviders: async (rolleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerFindRolleByIdWithServiceProviders', 'rolleId', rolleId)
            const localVarPath = `/api/rolle/{rolleId}`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rollen.
         * @summary 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [searchStr] The name for the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRollen: async (offset?: number, limit?: number, searchStr?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rolle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchStr !== undefined) {
                localVarQueryParameter['searchStr'] = searchStr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get service-providers for a rolle by its id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerGetRolleServiceProviderIds: async (rolleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerGetRolleServiceProviderIds', 'rolleId', rolleId)
            const localVarPath = `/api/rolle/{rolleId}/serviceProviders`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a service-provider from a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {string} serviceProviderId The id for the service provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerRemoveServiceProviderById: async (rolleId: string, serviceProviderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerRemoveServiceProviderById', 'rolleId', rolleId)
            // verify required parameter 'serviceProviderId' is not null or undefined
            assertParamExists('rolleControllerRemoveServiceProviderById', 'serviceProviderId', serviceProviderId)
            const localVarPath = `/api/rolle/{rolleId}/serviceProviders`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (serviceProviderId !== undefined) {
                localVarQueryParameter['serviceProviderId'] = serviceProviderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {UpdateRolleBodyParams} updateRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerUpdateRolle: async (rolleId: string, updateRolleBodyParams: UpdateRolleBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerUpdateRolle', 'rolleId', rolleId)
            // verify required parameter 'updateRolleBodyParams' is not null or undefined
            assertParamExists('rolleControllerUpdateRolle', 'updateRolleBodyParams', updateRolleBodyParams)
            const localVarPath = `/api/rolle/{rolleId}`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRolleBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolleApi - functional programming interface
 * @export
 */
export const RolleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolleApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a service-provider to a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {RolleServiceProviderBodyParams} rolleServiceProviderBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderBodyParams: RolleServiceProviderBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerAddServiceProviderById(rolleId, rolleServiceProviderBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add systemrecht to a rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerAddSystemRecht(rolleId, addSystemrechtBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerCreateRolle(createRolleBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a role by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerDeleteRolle(rolleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerDeleteRolle(rolleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerFindRolleByIdWithServiceProviders(rolleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleWithServiceProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerFindRolleByIdWithServiceProviders(rolleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rollen.
         * @summary 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [searchStr] The name for the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerFindRollen(offset?: number, limit?: number, searchStr?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RolleWithServiceProvidersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerFindRollen(offset, limit, searchStr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get service-providers for a rolle by its id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleServiceProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerGetRolleServiceProviderIds(rolleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a service-provider from a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {string} serviceProviderId The id for the service provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerRemoveServiceProviderById(rolleId, serviceProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {UpdateRolleBodyParams} updateRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerUpdateRolle(rolleId: string, updateRolleBodyParams: UpdateRolleBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleWithServiceProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerUpdateRolle(rolleId, updateRolleBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolleApi - factory interface
 * @export
 */
export const RolleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolleApiFp(configuration)
    return {
        /**
         * Add a service-provider to a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {RolleServiceProviderBodyParams} rolleServiceProviderBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderBodyParams: RolleServiceProviderBodyParams, options?: any): AxiosPromise<ServiceProviderResponse> {
            return localVarFp.rolleControllerAddServiceProviderById(rolleId, rolleServiceProviderBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Add systemrecht to a rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.rolleControllerAddSystemRecht(rolleId, addSystemrechtBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: any): AxiosPromise<RolleResponse> {
            return localVarFp.rolleControllerCreateRolle(createRolleBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a role by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerDeleteRolle(rolleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolleControllerDeleteRolle(rolleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRolleByIdWithServiceProviders(rolleId: string, options?: any): AxiosPromise<RolleWithServiceProvidersResponse> {
            return localVarFp.rolleControllerFindRolleByIdWithServiceProviders(rolleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rollen.
         * @summary 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [searchStr] The name for the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRollen(offset?: number, limit?: number, searchStr?: string, options?: any): AxiosPromise<Array<RolleWithServiceProvidersResponse>> {
            return localVarFp.rolleControllerFindRollen(offset, limit, searchStr, options).then((request) => request(axios, basePath));
        },
        /**
         * Get service-providers for a rolle by its id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: any): AxiosPromise<RolleServiceProviderResponse> {
            return localVarFp.rolleControllerGetRolleServiceProviderIds(rolleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a service-provider from a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {string} serviceProviderId The id for the service provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolleControllerRemoveServiceProviderById(rolleId, serviceProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {UpdateRolleBodyParams} updateRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerUpdateRolle(rolleId: string, updateRolleBodyParams: UpdateRolleBodyParams, options?: any): AxiosPromise<RolleWithServiceProvidersResponse> {
            return localVarFp.rolleControllerUpdateRolle(rolleId, updateRolleBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolleApi - interface
 * @export
 * @interface RolleApi
 */
export interface RolleApiInterface {
    /**
     * Add a service-provider to a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {RolleServiceProviderBodyParams} rolleServiceProviderBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderBodyParams: RolleServiceProviderBodyParams, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderResponse>;

    /**
     * Add systemrecht to a rolle.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Create a new rolle.
     * @summary 
     * @param {CreateRolleBodyParams} createRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig): AxiosPromise<RolleResponse>;

    /**
     * Delete a role by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerDeleteRolle(rolleId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerFindRolleByIdWithServiceProviders(rolleId: string, options?: AxiosRequestConfig): AxiosPromise<RolleWithServiceProvidersResponse>;

    /**
     * List all rollen.
     * @summary 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [searchStr] The name for the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerFindRollen(offset?: number, limit?: number, searchStr?: string, options?: AxiosRequestConfig): AxiosPromise<Array<RolleWithServiceProvidersResponse>>;

    /**
     * Get service-providers for a rolle by its id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: AxiosRequestConfig): AxiosPromise<RolleServiceProviderResponse>;

    /**
     * Remove a service-provider from a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {string} serviceProviderId The id for the service provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Update rolle.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {UpdateRolleBodyParams} updateRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerUpdateRolle(rolleId: string, updateRolleBodyParams: UpdateRolleBodyParams, options?: AxiosRequestConfig): AxiosPromise<RolleWithServiceProvidersResponse>;

}

/**
 * RolleApi - object-oriented interface
 * @export
 * @class RolleApi
 * @extends {BaseAPI}
 */
export class RolleApi extends BaseAPI implements RolleApiInterface {
    /**
     * Add a service-provider to a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {RolleServiceProviderBodyParams} rolleServiceProviderBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderBodyParams: RolleServiceProviderBodyParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerAddServiceProviderById(rolleId, rolleServiceProviderBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add systemrecht to a rolle.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerAddSystemRecht(rolleId, addSystemrechtBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new rolle.
     * @summary 
     * @param {CreateRolleBodyParams} createRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerCreateRolle(createRolleBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a role by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerDeleteRolle(rolleId: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerDeleteRolle(rolleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerFindRolleByIdWithServiceProviders(rolleId: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerFindRolleByIdWithServiceProviders(rolleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rollen.
     * @summary 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [searchStr] The name for the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerFindRollen(offset?: number, limit?: number, searchStr?: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerFindRollen(offset, limit, searchStr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get service-providers for a rolle by its id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerGetRolleServiceProviderIds(rolleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a service-provider from a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {string} serviceProviderId The id for the service provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerRemoveServiceProviderById(rolleId, serviceProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update rolle.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {UpdateRolleBodyParams} updateRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerUpdateRolle(rolleId: string, updateRolleBodyParams: UpdateRolleBodyParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerUpdateRolle(rolleId, updateRolleBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}



/* tslint:disable */
/* eslint-disable */
/**
 * dBildungs IAM
 * The dBildungs IAM server API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddSystemrechtBodyParams
 */
export interface AddSystemrechtBodyParams {
    /**
     * 
     * @type {RollenSystemRecht}
     * @memberof AddSystemrechtBodyParams
     */
    'systemRecht': RollenSystemRecht;
}


/**
 * 
 * @export
 * @interface CreateOrganisationBodyParams
 */
export interface CreateOrganisationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'administriertVon'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'zugehoerigZu'?: string;
    /**
     * Required, if `typ` is equal to `SCHULE`
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'kennung'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'namensergaenzung'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganisationBodyParams
     */
    'kuerzel'?: string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof CreateOrganisationBodyParams
     */
    'typ': OrganisationsTyp;
    /**
     * 
     * @type {TraegerschaftTyp}
     * @memberof CreateOrganisationBodyParams
     */
    'traegerschaft'?: TraegerschaftTyp;
}


/**
 * 
 * @export
 * @interface CreatePersonBodyParams
 */
export interface CreatePersonBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'stammorganisation'?: string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof CreatePersonBodyParams
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof CreatePersonBodyParams
     */
    'geburt'?: PersonBirthParams;
    /**
     * 
     * @type {Geschlecht}
     * @memberof CreatePersonBodyParams
     */
    'geschlecht'?: Geschlecht;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonBodyParams
     */
    'lokalisierung'?: string;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof CreatePersonBodyParams
     */
    'vertrauensstufe'?: Vertrauensstufe;
    /**
     * 
     * @type {boolean}
     * @memberof CreatePersonBodyParams
     */
    'auskunftssperre'?: boolean;
}


/**
 * 
 * @export
 * @interface CreatePersonenkontextBodyParams
 */
export interface CreatePersonenkontextBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonenkontextBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {Rolle}
     * @memberof CreatePersonenkontextBodyParams
     */
    'rolle': Rolle;
    /**
     * 
     * @type {Personenstatus}
     * @memberof CreatePersonenkontextBodyParams
     */
    'personenstatus'?: Personenstatus;
    /**
     * 
     * @type {Jahrgangsstufe}
     * @memberof CreatePersonenkontextBodyParams
     */
    'jahrgangsstufe'?: Jahrgangsstufe;
}


/**
 * 
 * @export
 * @interface CreateRolleBodyParams
 */
export interface CreateRolleBodyParams {
    /**
     * 
     * @type {string}
     * @memberof CreateRolleBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRolleBodyParams
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {RollenArt}
     * @memberof CreateRolleBodyParams
     */
    'rollenart': RollenArt;
    /**
     * 
     * @type {Set<RollenMerkmal>}
     * @memberof CreateRolleBodyParams
     */
    'merkmale': Set<RollenMerkmal>;
    /**
     * 
     * @type {Set<RollenSystemRecht>}
     * @memberof CreateRolleBodyParams
     */
    'systemrechte': Set<RollenSystemRecht>;
}


/**
 * 
 * @export
 * @interface DBiamCreatePersonenkontextBodyParams
 */
export interface DBiamCreatePersonenkontextBodyParams {
    /**
     * 
     * @type {string}
     * @memberof DBiamCreatePersonenkontextBodyParams
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamCreatePersonenkontextBodyParams
     */
    'organisationId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamCreatePersonenkontextBodyParams
     */
    'rolleId': string;
}
/**
 * 
 * @export
 * @interface DBiamPersonenkontextResponse
 */
export interface DBiamPersonenkontextResponse {
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenkontextResponse
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenkontextResponse
     */
    'organisationId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenkontextResponse
     */
    'rolleId': string;
}
/**
 * 
 * @export
 * @interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
 */
export interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response {
    /**
     * 
     * @type {number}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<DBiamPersonenuebersichtResponse>}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response
     */
    'items': Array<DBiamPersonenuebersichtResponse>;
}
/**
 * 
 * @export
 * @interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200ResponseAllOf
 */
export interface DBiamPersonenuebersichtControllerFindPersonenuebersichten200ResponseAllOf {
    /**
     * 
     * @type {Array<DBiamPersonenuebersichtResponse>}
     * @memberof DBiamPersonenuebersichtControllerFindPersonenuebersichten200ResponseAllOf
     */
    'items': Array<DBiamPersonenuebersichtResponse>;
}
/**
 * 
 * @export
 * @interface DBiamPersonenuebersichtResponse
 */
export interface DBiamPersonenuebersichtResponse {
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'personId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'nachname': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'benutzername': string;
    /**
     * 
     * @type {Array<DBiamPersonenzuordnungResponse>}
     * @memberof DBiamPersonenuebersichtResponse
     */
    'zuordnungen': Array<DBiamPersonenzuordnungResponse>;
}
/**
 * 
 * @export
 * @interface DBiamPersonenzuordnungResponse
 */
export interface DBiamPersonenzuordnungResponse {
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'sskId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'rolleId': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'sskName': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'sskDstNr': string;
    /**
     * 
     * @type {string}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'rolle': string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof DBiamPersonenzuordnungResponse
     */
    'typ': OrganisationsTyp;
}


/**
 * 
 * @export
 * @interface DeleteRevisionBodyParams
 */
export interface DeleteRevisionBodyParams {
    /**
     * The revision of a personenkontext.
     * @type {string}
     * @memberof DeleteRevisionBodyParams
     */
    'revision': string;
}
/**
 * 
 * @export
 * @interface FindRollenResponse
 */
export interface FindRollenResponse {
    /**
     * 
     * @type {Array<RolleResponse>}
     * @memberof FindRollenResponse
     */
    'moeglicheRollen': Array<RolleResponse>;
    /**
     * 
     * @type {number}
     * @memberof FindRollenResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface FindSchulstrukturknotenResponse
 */
export interface FindSchulstrukturknotenResponse {
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof FindSchulstrukturknotenResponse
     */
    'moeglicheSsks': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {number}
     * @memberof FindSchulstrukturknotenResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Geschlecht = {
    M: 'm',
    W: 'w',
    D: 'd',
    X: 'x'
} as const;

export type Geschlecht = typeof Geschlecht[keyof typeof Geschlecht];


/**
 * The new jahrgangsstufe of the personenkontext.
 * @export
 * @enum {string}
 */

export const Jahrgangsstufe = {
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10'
} as const;

export type Jahrgangsstufe = typeof Jahrgangsstufe[keyof typeof Jahrgangsstufe];


/**
 * 
 * @export
 * @interface LoeschungResponse
 */
export interface LoeschungResponse {
    /**
     * 
     * @type {string}
     * @memberof LoeschungResponse
     */
    'zeitpunkt': string;
}
/**
 * 
 * @export
 * @interface OrganisationByIdBodyParams
 */
export interface OrganisationByIdBodyParams {
    /**
     * The id of an organization
     * @type {string}
     * @memberof OrganisationByIdBodyParams
     */
    'organisationId': string;
}
/**
 * 
 * @export
 * @interface OrganisationResponse
 */
export interface OrganisationResponse {
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'administriertVon': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'kennung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'namensergaenzung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponse
     */
    'kuerzel': string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof OrganisationResponse
     */
    'typ': OrganisationsTyp;
    /**
     * 
     * @type {TraegerschaftTyp}
     * @memberof OrganisationResponse
     */
    'traegerschaft': TraegerschaftTyp;
}


/**
 * 
 * @export
 * @interface OrganisationResponseLegacy
 */
export interface OrganisationResponseLegacy {
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'administriertVon': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'kennung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'namensergaenzung': string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganisationResponseLegacy
     */
    'kuerzel': string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof OrganisationResponseLegacy
     */
    'typ': OrganisationsTyp;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const OrganisationsTyp = {
    Root: 'ROOT',
    Land: 'LAND',
    Traeger: 'TRAEGER',
    Schule: 'SCHULE',
    Klasse: 'KLASSE',
    Anbieter: 'ANBIETER',
    SonstigeOrganisationEinrichtung: 'SONSTIGE ORGANISATION / EINRICHTUNG',
    Unbestaetigt: 'UNBESTAETIGT'
} as const;

export type OrganisationsTyp = typeof OrganisationsTyp[keyof typeof OrganisationsTyp];


/**
 * 
 * @export
 * @interface PersonBirthParams
 */
export interface PersonBirthParams {
    /**
     * 
     * @type {string}
     * @memberof PersonBirthParams
     */
    'datum'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonBirthParams
     */
    'geburtsort'?: string;
}
/**
 * 
 * @export
 * @interface PersonControllerFindPersonenkontexte200Response
 */
export interface PersonControllerFindPersonenkontexte200Response {
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonControllerFindPersonenkontexte200Response
     */
    'items': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonControllerFindPersonenkontexte200ResponseAllOf
 */
export interface PersonControllerFindPersonenkontexte200ResponseAllOf {
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonControllerFindPersonenkontexte200ResponseAllOf
     */
    'items': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonFrontendControllerFindPersons200Response
 */
export interface PersonFrontendControllerFindPersons200Response {
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'limit': number;
    /**
     * 
     * @type {Array<PersonendatensatzResponse>}
     * @memberof PersonFrontendControllerFindPersons200Response
     */
    'items': Array<PersonendatensatzResponse>;
}
/**
 * 
 * @export
 * @interface PersonFrontendControllerFindPersons200ResponseAllOf
 */
export interface PersonFrontendControllerFindPersons200ResponseAllOf {
    /**
     * 
     * @type {Array<PersonendatensatzResponse>}
     * @memberof PersonFrontendControllerFindPersons200ResponseAllOf
     */
    'items': Array<PersonendatensatzResponse>;
}
/**
 * 
 * @export
 * @interface PersonNameParams
 */
export interface PersonNameParams {
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'familienname': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'vorname': string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'initialenfamilienname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'initialenvorname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'rufname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'titel'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'anrede'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'namenssuffix'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersonNameParams
     */
    'namenspraefix'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PersonNameParams
     */
    'sortierindex'?: string;
}
/**
 * 
 * @export
 * @interface PersonResponse
 */
export interface PersonResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'referrer': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'mandant': string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof PersonResponse
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof PersonResponse
     */
    'geburt': PersonBirthParams | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'stammorganisation': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'geschlecht': string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'lokalisierung': string | null;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof PersonResponse
     */
    'vertrauensstufe': Vertrauensstufe;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'revision': string;
    /**
     * Initiales Benutzerpasswort, muss nach der ersten Anmeldung geändert werden
     * @type {string}
     * @memberof PersonResponse
     */
    'startpasswort': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponse
     */
    'personalnummer': string | null;
}


/**
 * 
 * @export
 * @interface PersonResponseAutomapper
 */
export interface PersonResponseAutomapper {
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'referrer': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'mandant': string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof PersonResponseAutomapper
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof PersonResponseAutomapper
     */
    'geburt': PersonBirthParams;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'stammorganisation': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'geschlecht': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'lokalisierung': string;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof PersonResponseAutomapper
     */
    'vertrauensstufe': Vertrauensstufe;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'revision': string;
    /**
     * Initiales Benutzerpasswort, muss nach der ersten Anmeldung geändert werden
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'startpasswort': string;
    /**
     * 
     * @type {string}
     * @memberof PersonResponseAutomapper
     */
    'personalnummer': string;
}


/**
 * 
 * @export
 * @interface PersonendatensatzResponse
 */
export interface PersonendatensatzResponse {
    /**
     * 
     * @type {PersonResponse}
     * @memberof PersonendatensatzResponse
     */
    'person': PersonResponse;
}
/**
 * 
 * @export
 * @interface PersonendatensatzResponseAutomapper
 */
export interface PersonendatensatzResponseAutomapper {
    /**
     * 
     * @type {PersonResponseAutomapper}
     * @memberof PersonendatensatzResponseAutomapper
     */
    'person': PersonResponseAutomapper;
    /**
     * 
     * @type {Array<PersonenkontextResponse>}
     * @memberof PersonendatensatzResponseAutomapper
     */
    'personenkontexte': Array<PersonenkontextResponse>;
}
/**
 * 
 * @export
 * @interface PersonenkontextResponse
 */
export interface PersonenkontextResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'referrer': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'mandant': string;
    /**
     * 
     * @type {object}
     * @memberof PersonenkontextResponse
     */
    'organisation': object;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'rolle': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'personenstatus': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'jahrgangsstufe': string;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'sichtfreigabe': string;
    /**
     * 
     * @type {LoeschungResponse}
     * @memberof PersonenkontextResponse
     */
    'loeschung': LoeschungResponse;
    /**
     * 
     * @type {string}
     * @memberof PersonenkontextResponse
     */
    'revision': string;
}
/**
 * The new personenstatus of the personenkontext.
 * @export
 * @enum {string}
 */

export const Personenstatus = {
    Aktiv: 'AKTIV'
} as const;

export type Personenstatus = typeof Personenstatus[keyof typeof Personenstatus];


/**
 * 
 * @export
 * @interface RawPagedResponse
 */
export interface RawPagedResponse {
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof RawPagedResponse
     */
    'limit': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RawPagedResponse
     */
    'items': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Rolle = {
    Lern: 'LERN',
    Lehr: 'LEHR',
    Extern: 'EXTERN',
    Orgadmin: 'ORGADMIN',
    Leit: 'LEIT',
    Sysadmin: 'SYSADMIN'
} as const;

export type Rolle = typeof Rolle[keyof typeof Rolle];


/**
 * 
 * @export
 * @interface RolleResponse
 */
export interface RolleResponse {
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RolleResponse
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {RollenArt}
     * @memberof RolleResponse
     */
    'rollenart': RollenArt;
    /**
     * 
     * @type {Set<RollenMerkmal>}
     * @memberof RolleResponse
     */
    'merkmale': Set<RollenMerkmal>;
    /**
     * 
     * @type {Set<RollenSystemRecht>}
     * @memberof RolleResponse
     */
    'systemrechte': Set<RollenSystemRecht>;
}


/**
 * 
 * @export
 * @interface RolleServiceProviderQueryParams
 */
export interface RolleServiceProviderQueryParams {
    /**
     * The id for the rolle.
     * @type {string}
     * @memberof RolleServiceProviderQueryParams
     */
    'serviceProviderId': string;
}
/**
 * 
 * @export
 * @interface RolleServiceProviderResponse
 */
export interface RolleServiceProviderResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof RolleServiceProviderResponse
     */
    'serviceProviderIds': Array<string>;
}
/**
 * 
 * @export
 * @interface RolleWithServiceProvidersResponse
 */
export interface RolleWithServiceProvidersResponse {
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RolleWithServiceProvidersResponse
     */
    'administeredBySchulstrukturknoten': string;
    /**
     * 
     * @type {RollenArt}
     * @memberof RolleWithServiceProvidersResponse
     */
    'rollenart': RollenArt;
    /**
     * 
     * @type {Set<RollenMerkmal>}
     * @memberof RolleWithServiceProvidersResponse
     */
    'merkmale': Set<RollenMerkmal>;
    /**
     * 
     * @type {Set<RollenSystemRecht>}
     * @memberof RolleWithServiceProvidersResponse
     */
    'systemrechte': Set<RollenSystemRecht>;
    /**
     * 
     * @type {Array<ServiceProviderIdNameResponse>}
     * @memberof RolleWithServiceProvidersResponse
     */
    'serviceProviders': Array<ServiceProviderIdNameResponse>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RollenArt = {
    Lern: 'LERN',
    Lehr: 'LEHR',
    Extern: 'EXTERN',
    Orgadmin: 'ORGADMIN',
    Leit: 'LEIT',
    Sysadmin: 'SYSADMIN'
} as const;

export type RollenArt = typeof RollenArt[keyof typeof RollenArt];


/**
 * 
 * @export
 * @enum {string}
 */

export const RollenMerkmal = {
    BefristungPflicht: 'BEFRISTUNG_PFLICHT',
    KopersPflicht: 'KOPERS_PFLICHT'
} as const;

export type RollenMerkmal = typeof RollenMerkmal[keyof typeof RollenMerkmal];


/**
 * 
 * @export
 * @enum {string}
 */

export const RollenSystemRecht = {
    RollenVerwalten: 'ROLLEN_VERWALTEN',
    PersonenVerwalten: 'PERSONEN_VERWALTEN',
    SchulenVerwalten: 'SCHULEN_VERWALTEN',
    KlassenVerwalten: 'KLASSEN_VERWALTEN',
    SchultraegerVerwalten: 'SCHULTRAEGER_VERWALTEN'
} as const;

export type RollenSystemRecht = typeof RollenSystemRecht[keyof typeof RollenSystemRecht];


/**
 * 
 * @export
 * @interface ServiceProviderIdNameResponse
 */
export interface ServiceProviderIdNameResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderIdNameResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderIdNameResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceProviderKategorie = {
    Email: 'EMAIL',
    Unterricht: 'UNTERRICHT',
    Verwaltung: 'VERWALTUNG',
    Hinweise: 'HINWEISE',
    Angebote: 'ANGEBOTE'
} as const;

export type ServiceProviderKategorie = typeof ServiceProviderKategorie[keyof typeof ServiceProviderKategorie];


/**
 * 
 * @export
 * @interface ServiceProviderResponse
 */
export interface ServiceProviderResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'name': string;
    /**
     * 
     * @type {ServiceProviderTarget}
     * @memberof ServiceProviderResponse
     */
    'target': ServiceProviderTarget;
    /**
     * Can be undefined, if `target` is not equal to `URL`
     * @type {string}
     * @memberof ServiceProviderResponse
     */
    'url': string;
    /**
     * 
     * @type {ServiceProviderKategorie}
     * @memberof ServiceProviderResponse
     */
    'kategorie': ServiceProviderKategorie;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderResponse
     */
    'hasLogo': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ServiceProviderTarget = {
    Url: 'URL',
    SchulportalAdministration: 'SCHULPORTAL_ADMINISTRATION'
} as const;

export type ServiceProviderTarget = typeof ServiceProviderTarget[keyof typeof ServiceProviderTarget];


/**
 * 
 * @export
 * @enum {string}
 */

export const Sichtfreigabe = {
    Ja: 'ja',
    Nein: 'nein'
} as const;

export type Sichtfreigabe = typeof Sichtfreigabe[keyof typeof Sichtfreigabe];


/**
 * 
 * @export
 * @interface SystemrechtResponse
 */
export interface SystemrechtResponse {
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'ROLLEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'KLASSEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'SCHULEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'PERSONEN_VERWALTEN': Array<OrganisationResponseLegacy>;
    /**
     * 
     * @type {Array<OrganisationResponseLegacy>}
     * @memberof SystemrechtResponse
     */
    'SCHULTRAEGER_VERWALTEN': Array<OrganisationResponseLegacy>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TraegerschaftTyp = {
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06'
} as const;

export type TraegerschaftTyp = typeof TraegerschaftTyp[keyof typeof TraegerschaftTyp];


/**
 * 
 * @export
 * @interface UpdateOrganisationBodyParams
 */
export interface UpdateOrganisationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'administriertVon'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'zugehoerigZu'?: string;
    /**
     * Required, if `typ` is equal to `SCHULE`
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'kennung'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'namensergaenzung'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganisationBodyParams
     */
    'kuerzel'?: string;
    /**
     * 
     * @type {OrganisationsTyp}
     * @memberof UpdateOrganisationBodyParams
     */
    'typ': OrganisationsTyp;
    /**
     * 
     * @type {TraegerschaftTyp}
     * @memberof UpdateOrganisationBodyParams
     */
    'traegerschaft'?: TraegerschaftTyp;
}


/**
 * 
 * @export
 * @interface UpdatePersonBodyParams
 */
export interface UpdatePersonBodyParams {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'stammorganisation'?: string;
    /**
     * 
     * @type {PersonNameParams}
     * @memberof UpdatePersonBodyParams
     */
    'name': PersonNameParams;
    /**
     * 
     * @type {PersonBirthParams}
     * @memberof UpdatePersonBodyParams
     */
    'geburt'?: PersonBirthParams;
    /**
     * 
     * @type {Geschlecht}
     * @memberof UpdatePersonBodyParams
     */
    'geschlecht'?: Geschlecht;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'lokalisierung'?: string;
    /**
     * 
     * @type {Vertrauensstufe}
     * @memberof UpdatePersonBodyParams
     */
    'vertrauensstufe'?: Vertrauensstufe;
    /**
     * 
     * @type {boolean}
     * @memberof UpdatePersonBodyParams
     */
    'auskunftssperre'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonBodyParams
     */
    'revision': string;
}


/**
 * 
 * @export
 * @interface UpdatePersonenkontextBodyParams
 */
export interface UpdatePersonenkontextBodyParams {
    /**
     * The new referrer of the personenkontext.
     * @type {string}
     * @memberof UpdatePersonenkontextBodyParams
     */
    'referrer'?: string;
    /**
     * 
     * @type {Personenstatus}
     * @memberof UpdatePersonenkontextBodyParams
     */
    'personenstatus'?: Personenstatus;
    /**
     * 
     * @type {Jahrgangsstufe}
     * @memberof UpdatePersonenkontextBodyParams
     */
    'jahrgangsstufe'?: Jahrgangsstufe;
    /**
     * The revision of the personenkontext.
     * @type {string}
     * @memberof UpdatePersonenkontextBodyParams
     */
    'revision': string;
}


/**
 * 
 * @export
 * @interface UserinfoResponse
 */
export interface UserinfoResponse {
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'sub': string;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'personId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'given_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'family_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'middle_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'preferred_username': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'profile': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'picture': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'website': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'email': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserinfoResponse
     */
    'email_verified': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'zoneinfo': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'locale': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserinfoResponse
     */
    'phone_number': string | null;
    /**
     * 
     * @type {number}
     * @memberof UserinfoResponse
     */
    'updated_at': number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Vertrauensstufe = {
    Kein: 'KEIN',
    Unbe: 'UNBE',
    Teil: 'TEIL',
    Voll: 'VOLL'
} as const;

export type Vertrauensstufe = typeof Vertrauensstufe[keyof typeof Vertrauensstufe];



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logininfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogin: async (redirectUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserinfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerLogin(redirectUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationControllerLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationControllerLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Info about logged in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerInfo(options?: any): AxiosPromise<UserinfoResponse> {
            return localVarFp.authenticationControllerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to start OIDC authentication.
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogin(redirectUrl?: string, options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerLogin(redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to log out the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationControllerLogout(options?: any): AxiosPromise<void> {
            return localVarFp.authenticationControllerLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 
     * @summary Info about logged in user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerInfo(options?: AxiosRequestConfig): AxiosPromise<UserinfoResponse>;

    /**
     * 
     * @summary Used to start OIDC authentication.
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Used to log out the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authenticationControllerLogout(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 
     * @summary Info about logged in user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerInfo(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to start OIDC authentication.
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerLogin(redirectUrl?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerLogin(redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to log out the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticationControllerLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticationControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DbiamPersonenkontexteApi - axios parameter creator
 * @export
 */
export const DbiamPersonenkontexteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DBiamCreatePersonenkontextBodyParams} dBiamCreatePersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerCreatePersonenkontext: async (dBiamCreatePersonenkontextBodyParams: DBiamCreatePersonenkontextBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dBiamCreatePersonenkontextBodyParams' is not null or undefined
            assertParamExists('dBiamPersonenkontextControllerCreatePersonenkontext', 'dBiamCreatePersonenkontextBodyParams', dBiamCreatePersonenkontextBodyParams)
            const localVarPath = `/api/dbiam/personenkontext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dBiamCreatePersonenkontextBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerFindPersonenkontextsByPerson: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('dBiamPersonenkontextControllerFindPersonenkontextsByPerson', 'personId', personId)
            const localVarPath = `/api/dbiam/personenkontext/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DbiamPersonenkontexteApi - functional programming interface
 * @export
 */
export const DbiamPersonenkontexteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DbiamPersonenkontexteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DBiamCreatePersonenkontextBodyParams} dBiamCreatePersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenkontextControllerCreatePersonenkontext(dBiamCreatePersonenkontextBodyParams: DBiamCreatePersonenkontextBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBiamPersonenkontextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenkontextControllerCreatePersonenkontext(dBiamCreatePersonenkontextBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DBiamPersonenkontextResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DbiamPersonenkontexteApi - factory interface
 * @export
 */
export const DbiamPersonenkontexteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DbiamPersonenkontexteApiFp(configuration)
    return {
        /**
         * 
         * @param {DBiamCreatePersonenkontextBodyParams} dBiamCreatePersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerCreatePersonenkontext(dBiamCreatePersonenkontextBodyParams: DBiamCreatePersonenkontextBodyParams, options?: any): AxiosPromise<DBiamPersonenkontextResponse> {
            return localVarFp.dBiamPersonenkontextControllerCreatePersonenkontext(dBiamCreatePersonenkontextBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: any): AxiosPromise<Array<DBiamPersonenkontextResponse>> {
            return localVarFp.dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DbiamPersonenkontexteApi - interface
 * @export
 * @interface DbiamPersonenkontexteApi
 */
export interface DbiamPersonenkontexteApiInterface {
    /**
     * 
     * @param {DBiamCreatePersonenkontextBodyParams} dBiamCreatePersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApiInterface
     */
    dBiamPersonenkontextControllerCreatePersonenkontext(dBiamCreatePersonenkontextBodyParams: DBiamCreatePersonenkontextBodyParams, options?: AxiosRequestConfig): AxiosPromise<DBiamPersonenkontextResponse>;

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApiInterface
     */
    dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: AxiosRequestConfig): AxiosPromise<Array<DBiamPersonenkontextResponse>>;

}

/**
 * DbiamPersonenkontexteApi - object-oriented interface
 * @export
 * @class DbiamPersonenkontexteApi
 * @extends {BaseAPI}
 */
export class DbiamPersonenkontexteApi extends BaseAPI implements DbiamPersonenkontexteApiInterface {
    /**
     * 
     * @param {DBiamCreatePersonenkontextBodyParams} dBiamCreatePersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApi
     */
    public dBiamPersonenkontextControllerCreatePersonenkontext(dBiamCreatePersonenkontextBodyParams: DBiamCreatePersonenkontextBodyParams, options?: AxiosRequestConfig) {
        return DbiamPersonenkontexteApiFp(this.configuration).dBiamPersonenkontextControllerCreatePersonenkontext(dBiamCreatePersonenkontextBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenkontexteApi
     */
    public dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId: string, options?: AxiosRequestConfig) {
        return DbiamPersonenkontexteApiFp(this.configuration).dBiamPersonenkontextControllerFindPersonenkontextsByPerson(personId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DbiamPersonenuebersichtApi - axios parameter creator
 * @export
 */
export const DbiamPersonenuebersichtApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichten: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dbiam/personenuebersicht`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson', 'personId', personId)
            const localVarPath = `/api/dbiam/personenuebersicht/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DbiamPersonenuebersichtApi - functional programming interface
 * @export
 */
export const DbiamPersonenuebersichtApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DbiamPersonenuebersichtApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenuebersichtControllerFindPersonenuebersichten(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenuebersichtControllerFindPersonenuebersichten(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DBiamPersonenuebersichtResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DbiamPersonenuebersichtApi - factory interface
 * @export
 */
export const DbiamPersonenuebersichtApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DbiamPersonenuebersichtApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichten(offset?: number, limit?: number, options?: any): AxiosPromise<DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response> {
            return localVarFp.dBiamPersonenuebersichtControllerFindPersonenuebersichten(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The ID for the person.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: any): AxiosPromise<DBiamPersonenuebersichtResponse> {
            return localVarFp.dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DbiamPersonenuebersichtApi - interface
 * @export
 * @interface DbiamPersonenuebersichtApi
 */
export interface DbiamPersonenuebersichtApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApiInterface
     */
    dBiamPersonenuebersichtControllerFindPersonenuebersichten(offset?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<DBiamPersonenuebersichtControllerFindPersonenuebersichten200Response>;

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApiInterface
     */
    dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: AxiosRequestConfig): AxiosPromise<DBiamPersonenuebersichtResponse>;

}

/**
 * DbiamPersonenuebersichtApi - object-oriented interface
 * @export
 * @class DbiamPersonenuebersichtApi
 * @extends {BaseAPI}
 */
export class DbiamPersonenuebersichtApi extends BaseAPI implements DbiamPersonenuebersichtApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApi
     */
    public dBiamPersonenuebersichtControllerFindPersonenuebersichten(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DbiamPersonenuebersichtApiFp(this.configuration).dBiamPersonenuebersichtControllerFindPersonenuebersichten(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The ID for the person.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DbiamPersonenuebersichtApi
     */
    public dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId: string, options?: AxiosRequestConfig) {
        return DbiamPersonenuebersichtApiFp(this.configuration).dBiamPersonenuebersichtControllerFindPersonenuebersichtenByPerson(personId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganisationenApi - axios parameter creator
 * @export
 */
export const OrganisationenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddAdministrierteOrganisation: async (organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerAddAdministrierteOrganisation', 'organisationId', organisationId)
            // verify required parameter 'organisationByIdBodyParams' is not null or undefined
            assertParamExists('organisationControllerAddAdministrierteOrganisation', 'organisationByIdBodyParams', organisationByIdBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}/administriert`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationByIdBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddZugehoerigeOrganisation: async (organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerAddZugehoerigeOrganisation', 'organisationId', organisationId)
            // verify required parameter 'organisationByIdBodyParams' is not null or undefined
            assertParamExists('organisationControllerAddZugehoerigeOrganisation', 'organisationByIdBodyParams', organisationByIdBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}/zugehoerig`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organisationByIdBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerCreateOrganisation: async (createOrganisationBodyParams: CreateOrganisationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganisationBodyParams' is not null or undefined
            assertParamExists('organisationControllerCreateOrganisation', 'createOrganisationBodyParams', createOrganisationBodyParams)
            const localVarPath = `/api/organisationen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganisationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganisationById: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerFindOrganisationById', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {string} [searchString] 
         * @param {OrganisationsTyp} [typ] 
         * @param {Array<RollenSystemRecht>} [systemrechte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganizations: async (offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organisationen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (kennung !== undefined) {
                localVarQueryParameter['kennung'] = kennung;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }

            if (typ !== undefined) {
                localVarQueryParameter['typ'] = typ;
            }

            if (systemrechte) {
                localVarQueryParameter['systemrechte'] = systemrechte;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetAdministrierteOrganisationen: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerGetAdministrierteOrganisationen', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}/administriert`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootOrganisation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organisationen/root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetZugehoerigeOrganisationen: async (organisationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerGetZugehoerigeOrganisationen', 'organisationId', organisationId)
            const localVarPath = `/api/organisationen/{organisationId}/zugehoerig`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisation: async (organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisation', 'organisationId', organisationId)
            // verify required parameter 'updateOrganisationBodyParams' is not null or undefined
            assertParamExists('organisationControllerUpdateOrganisation', 'updateOrganisationBodyParams', updateOrganisationBodyParams)
            const localVarPath = `/api/organisationen/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganisationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationenApi - functional programming interface
 * @export
 */
export const OrganisationenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponseLegacy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerCreateOrganisation(createOrganisationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponseLegacy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerFindOrganisationById(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {string} [searchString] 
         * @param {OrganisationsTyp} [typ] 
         * @param {Array<RollenSystemRecht>} [systemrechte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerFindOrganizations(offset, limit, kennung, name, searchString, typ, systemrechte, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponseLegacy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetAdministrierteOrganisationen(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetRootOrganisation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponseLegacy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetRootOrganisation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganisationResponseLegacy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerGetZugehoerigeOrganisationen(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganisationResponseLegacy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganisationenApi - factory interface
 * @export
 */
export const OrganisationenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationenApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: any): AxiosPromise<OrganisationResponseLegacy> {
            return localVarFp.organisationControllerCreateOrganisation(createOrganisationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganisationById(organisationId: string, options?: any): AxiosPromise<OrganisationResponseLegacy> {
            return localVarFp.organisationControllerFindOrganisationById(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [kennung] 
         * @param {string} [name] 
         * @param {string} [searchString] 
         * @param {OrganisationsTyp} [typ] 
         * @param {Array<RollenSystemRecht>} [systemrechte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, options?: any): AxiosPromise<Array<OrganisationResponse>> {
            return localVarFp.organisationControllerFindOrganizations(offset, limit, kennung, name, searchString, typ, systemrechte, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: any): AxiosPromise<Array<OrganisationResponseLegacy>> {
            return localVarFp.organisationControllerGetAdministrierteOrganisationen(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetRootOrganisation(options?: any): AxiosPromise<OrganisationResponseLegacy> {
            return localVarFp.organisationControllerGetRootOrganisation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: any): AxiosPromise<Array<OrganisationResponseLegacy>> {
            return localVarFp.organisationControllerGetZugehoerigeOrganisationen(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organisationId The id of an organization
         * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: any): AxiosPromise<OrganisationResponseLegacy> {
            return localVarFp.organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationenApi - interface
 * @export
 * @interface OrganisationenApi
 */
export interface OrganisationenApiInterface {
    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponseLegacy>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponseLegacy>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [kennung] 
     * @param {string} [name] 
     * @param {string} [searchString] 
     * @param {OrganisationsTyp} [typ] 
     * @param {Array<RollenSystemRecht>} [systemrechte] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponse>>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponseLegacy>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetRootOrganisation(options?: AxiosRequestConfig): AxiosPromise<OrganisationResponseLegacy>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig): AxiosPromise<Array<OrganisationResponseLegacy>>;

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApiInterface
     */
    organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig): AxiosPromise<OrganisationResponseLegacy>;

}

/**
 * OrganisationenApi - object-oriented interface
 * @export
 * @class OrganisationenApi
 * @extends {BaseAPI}
 */
export class OrganisationenApi extends BaseAPI implements OrganisationenApiInterface {
    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerAddAdministrierteOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerAddAdministrierteOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {OrganisationByIdBodyParams} organisationByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerAddZugehoerigeOrganisation(organisationId: string, organisationByIdBodyParams: OrganisationByIdBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerAddZugehoerigeOrganisation(organisationId, organisationByIdBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateOrganisationBodyParams} createOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerCreateOrganisation(createOrganisationBodyParams: CreateOrganisationBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerCreateOrganisation(createOrganisationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerFindOrganisationById(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerFindOrganisationById(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [kennung] 
     * @param {string} [name] 
     * @param {string} [searchString] 
     * @param {OrganisationsTyp} [typ] 
     * @param {Array<RollenSystemRecht>} [systemrechte] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerFindOrganizations(offset?: number, limit?: number, kennung?: string, name?: string, searchString?: string, typ?: OrganisationsTyp, systemrechte?: Array<RollenSystemRecht>, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerFindOrganizations(offset, limit, kennung, name, searchString, typ, systemrechte, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetAdministrierteOrganisationen(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetAdministrierteOrganisationen(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetRootOrganisation(options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetRootOrganisation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerGetZugehoerigeOrganisationen(organisationId: string, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerGetZugehoerigeOrganisationen(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organisationId The id of an organization
     * @param {UpdateOrganisationBodyParams} updateOrganisationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationenApi
     */
    public organisationControllerUpdateOrganisation(organisationId: string, updateOrganisationBodyParams: UpdateOrganisationBodyParams, options?: AxiosRequestConfig) {
        return OrganisationenApiFp(this.configuration).organisationControllerUpdateOrganisation(organisationId, updateOrganisationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenApi - axios parameter creator
 * @export
 */
export const PersonenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePersonBodyParams} createPersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePerson: async (createPersonBodyParams: CreatePersonBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonBodyParams' is not null or undefined
            assertParamExists('personControllerCreatePerson', 'createPersonBodyParams', createPersonBodyParams)
            const localVarPath = `/api/personen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePersonenkontext: async (personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerCreatePersonenkontext', 'personId', personId)
            // verify required parameter 'createPersonenkontextBodyParams' is not null or undefined
            assertParamExists('personControllerCreatePersonenkontext', 'createPersonenkontextBodyParams', createPersonenkontextBodyParams)
            const localVarPath = `/api/personen/{personId}/personenkontexte`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonenkontextBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonById: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerFindPersonById', 'personId', personId)
            const localVarPath = `/api/personen/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonenkontexte: async (personId: string, offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerFindPersonenkontexte', 'personId', personId)
            const localVarPath = `/api/personen/{personId}/personenkontexte`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (rolle !== undefined) {
                localVarQueryParameter['rolle'] = rolle;
            }

            if (personenstatus !== undefined) {
                localVarQueryParameter['personenstatus'] = personenstatus;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersons: async (offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (familienname !== undefined) {
                localVarQueryParameter['familienname'] = familienname;
            }

            if (vorname !== undefined) {
                localVarQueryParameter['vorname'] = vorname;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }

            if (suchFilter !== undefined) {
                localVarQueryParameter['suchFilter'] = suchFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerResetPasswordByPersonId: async (personId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerResetPasswordByPersonId', 'personId', personId)
            const localVarPath = `/api/personen/{personId}/password`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePerson: async (personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personControllerUpdatePerson', 'personId', personId)
            // verify required parameter 'updatePersonBodyParams' is not null or undefined
            assertParamExists('personControllerUpdatePerson', 'updatePersonBodyParams', updatePersonBodyParams)
            const localVarPath = `/api/personen/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenApi - functional programming interface
 * @export
 */
export const PersonenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePersonBodyParams} createPersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerCreatePerson(createPersonBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerCreatePersonenkontext(personId, createPersonenkontextBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersonById(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersonById(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonControllerFindPersonenkontexte200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersonenkontexte(personId, offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonendatensatzResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, suchFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerResetPasswordByPersonId(personId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personControllerUpdatePerson(personId, updatePersonBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenApi - factory interface
 * @export
 */
export const PersonenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePersonBodyParams} createPersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerCreatePerson(createPersonBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.personControllerCreatePersonenkontext(personId, createPersonenkontextBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonById(personId: string, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerFindPersonById(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: any): AxiosPromise<PersonControllerFindPersonenkontexte200Response> {
            return localVarFp.personControllerFindPersonenkontexte(personId, offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: any): AxiosPromise<Array<PersonendatensatzResponse>> {
            return localVarFp.personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, suchFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerResetPasswordByPersonId(personId: string, options?: any): AxiosPromise<string> {
            return localVarFp.personControllerResetPasswordByPersonId(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {UpdatePersonBodyParams} updatePersonBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: any): AxiosPromise<PersonendatensatzResponse> {
            return localVarFp.personControllerUpdatePerson(personId, updatePersonBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenApi - interface
 * @export
 * @interface PersonenApi
 */
export interface PersonenApiInterface {
    /**
     * 
     * @param {CreatePersonBodyParams} createPersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersonById(personId: string, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): AxiosPromise<PersonControllerFindPersonenkontexte200Response>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: AxiosRequestConfig): AxiosPromise<Array<PersonendatensatzResponse>>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {UpdatePersonBodyParams} updatePersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApiInterface
     */
    personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponse>;

}

/**
 * PersonenApi - object-oriented interface
 * @export
 * @class PersonenApi
 * @extends {BaseAPI}
 */
export class PersonenApi extends BaseAPI implements PersonenApiInterface {
    /**
     * 
     * @param {CreatePersonBodyParams} createPersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerCreatePerson(createPersonBodyParams: CreatePersonBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerCreatePerson(createPersonBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {CreatePersonenkontextBodyParams} createPersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerCreatePersonenkontext(personId: string, createPersonenkontextBodyParams: CreatePersonenkontextBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerCreatePersonenkontext(personId, createPersonenkontextBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersonById(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersonById(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersonenkontexte(personId: string, offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersonenkontexte(personId, offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, suchFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerResetPasswordByPersonId(personId: string, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerResetPasswordByPersonId(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {UpdatePersonBodyParams} updatePersonBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenApi
     */
    public personControllerUpdatePerson(personId: string, updatePersonBodyParams: UpdatePersonBodyParams, options?: AxiosRequestConfig) {
        return PersonenApiFp(this.configuration).personControllerUpdatePerson(personId, updatePersonBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenFrontendApi - axios parameter creator
 * @export
 */
export const PersonenFrontendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personFrontendControllerFindPersons: async (offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personen-frontend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (familienname !== undefined) {
                localVarQueryParameter['familienname'] = familienname;
            }

            if (vorname !== undefined) {
                localVarQueryParameter['vorname'] = vorname;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }

            if (suchFilter !== undefined) {
                localVarQueryParameter['suchFilter'] = suchFilter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenFrontendApi - functional programming interface
 * @export
 */
export const PersonenFrontendApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenFrontendApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonFrontendControllerFindPersons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, suchFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenFrontendApi - factory interface
 * @export
 */
export const PersonenFrontendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenFrontendApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {string} [familienname] 
         * @param {string} [vorname] 
         * @param {'ja' | 'nein'} [sichtfreigabe] 
         * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: any): AxiosPromise<PersonFrontendControllerFindPersons200Response> {
            return localVarFp.personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, suchFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenFrontendApi - interface
 * @export
 * @interface PersonenFrontendApi
 */
export interface PersonenFrontendApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenFrontendApiInterface
     */
    personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: AxiosRequestConfig): AxiosPromise<PersonFrontendControllerFindPersons200Response>;

}

/**
 * PersonenFrontendApi - object-oriented interface
 * @export
 * @class PersonenFrontendApi
 * @extends {BaseAPI}
 */
export class PersonenFrontendApi extends BaseAPI implements PersonenFrontendApiInterface {
    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {string} [familienname] 
     * @param {string} [vorname] 
     * @param {'ja' | 'nein'} [sichtfreigabe] 
     * @param {string} [suchFilter] Search filter used to filter for Persons. It could be the vorname, familienname, referrer or the personalnummer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenFrontendApi
     */
    public personFrontendControllerFindPersons(offset?: number, limit?: number, referrer?: string, familienname?: string, vorname?: string, sichtfreigabe?: 'ja' | 'nein', suchFilter?: string, options?: AxiosRequestConfig) {
        return PersonenFrontendApiFp(this.configuration).personFrontendControllerFindPersons(offset, limit, referrer, familienname, vorname, sichtfreigabe, suchFilter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenkontextApi - axios parameter creator
 * @export
 */
export const PersonenkontextApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} rolleName Rolle name used to filter for rollen in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextFilterControllerFindRollen: async (rolleName: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleName' is not null or undefined
            assertParamExists('dbiamPersonenkontextFilterControllerFindRollen', 'rolleName', rolleName)
            const localVarPath = `/api/personenkontext/rollen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rolleName !== undefined) {
                localVarQueryParameter['rolleName'] = rolleName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
         * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextFilterControllerFindSchulstrukturknoten: async (rolleId: string, sskName?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('dbiamPersonenkontextFilterControllerFindSchulstrukturknoten', 'rolleId', rolleId)
            const localVarPath = `/api/personenkontext/schulstrukturknoten`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rolleId !== undefined) {
                localVarQueryParameter['rolleId'] = rolleId;
            }

            if (sskName !== undefined) {
                localVarQueryParameter['sskName'] = sskName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenkontextApi - functional programming interface
 * @export
 */
export const PersonenkontextApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenkontextApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} rolleName Rolle name used to filter for rollen in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dbiamPersonenkontextFilterControllerFindRollen(rolleName: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindRollenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dbiamPersonenkontextFilterControllerFindRollen(rolleName, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
         * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dbiamPersonenkontextFilterControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindSchulstrukturknotenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dbiamPersonenkontextFilterControllerFindSchulstrukturknoten(rolleId, sskName, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenkontextApi - factory interface
 * @export
 */
export const PersonenkontextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenkontextApiFp(configuration)
    return {
        /**
         * 
         * @param {string} rolleName Rolle name used to filter for rollen in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextFilterControllerFindRollen(rolleName: string, limit?: number, options?: any): AxiosPromise<FindRollenResponse> {
            return localVarFp.dbiamPersonenkontextFilterControllerFindRollen(rolleName, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
         * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
         * @param {number} [limit] The limit of items for the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dbiamPersonenkontextFilterControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: any): AxiosPromise<FindSchulstrukturknotenResponse> {
            return localVarFp.dbiamPersonenkontextFilterControllerFindSchulstrukturknoten(rolleId, sskName, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenkontextApi - interface
 * @export
 * @interface PersonenkontextApi
 */
export interface PersonenkontextApiInterface {
    /**
     * 
     * @param {string} rolleName Rolle name used to filter for rollen in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApiInterface
     */
    dbiamPersonenkontextFilterControllerFindRollen(rolleName: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<FindRollenResponse>;

    /**
     * 
     * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
     * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApiInterface
     */
    dbiamPersonenkontextFilterControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: AxiosRequestConfig): AxiosPromise<FindSchulstrukturknotenResponse>;

}

/**
 * PersonenkontextApi - object-oriented interface
 * @export
 * @class PersonenkontextApi
 * @extends {BaseAPI}
 */
export class PersonenkontextApi extends BaseAPI implements PersonenkontextApiInterface {
    /**
     * 
     * @param {string} rolleName Rolle name used to filter for rollen in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApi
     */
    public dbiamPersonenkontextFilterControllerFindRollen(rolleName: string, limit?: number, options?: AxiosRequestConfig) {
        return PersonenkontextApiFp(this.configuration).dbiamPersonenkontextFilterControllerFindRollen(rolleName, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rolleId RolleId used to filter for schulstrukturknoten in personenkontext.
     * @param {string} [sskName] Organisation/SSK name used to filter for schulstrukturknoten in personenkontext.
     * @param {number} [limit] The limit of items for the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontextApi
     */
    public dbiamPersonenkontextFilterControllerFindSchulstrukturknoten(rolleId: string, sskName?: string, limit?: number, options?: AxiosRequestConfig) {
        return PersonenkontextApiFp(this.configuration).dbiamPersonenkontextFilterControllerFindSchulstrukturknoten(rolleId, sskName, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonenkontexteApi - axios parameter creator
 * @export
 */
export const PersonenkontexteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerDeletePersonenkontextById: async (personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personenkontextId' is not null or undefined
            assertParamExists('personenkontextControllerDeletePersonenkontextById', 'personenkontextId', personenkontextId)
            // verify required parameter 'deleteRevisionBodyParams' is not null or undefined
            assertParamExists('personenkontextControllerDeletePersonenkontextById', 'deleteRevisionBodyParams', deleteRevisionBodyParams)
            const localVarPath = `/api/personenkontexte/{personenkontextId}`
                .replace(`{${"personenkontextId"}}`, encodeURIComponent(String(personenkontextId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRevisionBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontextById: async (personenkontextId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personenkontextId' is not null or undefined
            assertParamExists('personenkontextControllerFindPersonenkontextById', 'personenkontextId', personenkontextId)
            const localVarPath = `/api/personenkontexte/{personenkontextId}`
                .replace(`{${"personenkontextId"}}`, encodeURIComponent(String(personenkontextId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontexte: async (offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/personenkontexte`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (referrer !== undefined) {
                localVarQueryParameter['referrer'] = referrer;
            }

            if (rolle !== undefined) {
                localVarQueryParameter['rolle'] = rolle;
            }

            if (personenstatus !== undefined) {
                localVarQueryParameter['personenstatus'] = personenstatus;
            }

            if (sichtfreigabe !== undefined) {
                localVarQueryParameter['sichtfreigabe'] = sichtfreigabe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {RollenSystemRecht} systemRecht 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerHatSystemRecht: async (personId: string, systemRecht: RollenSystemRecht, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('personenkontextControllerHatSystemRecht', 'personId', personId)
            // verify required parameter 'systemRecht' is not null or undefined
            assertParamExists('personenkontextControllerHatSystemRecht', 'systemRecht', systemRecht)
            const localVarPath = `/api/personenkontexte/{personId}/hatSystemrecht`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (systemRecht !== undefined) {
                localVarQueryParameter['systemRecht'] = systemRecht;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {UpdatePersonenkontextBodyParams} updatePersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerUpdatePersonenkontextWithId: async (personenkontextId: string, updatePersonenkontextBodyParams: UpdatePersonenkontextBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personenkontextId' is not null or undefined
            assertParamExists('personenkontextControllerUpdatePersonenkontextWithId', 'personenkontextId', personenkontextId)
            // verify required parameter 'updatePersonenkontextBodyParams' is not null or undefined
            assertParamExists('personenkontextControllerUpdatePersonenkontextWithId', 'updatePersonenkontextBodyParams', updatePersonenkontextBodyParams)
            const localVarPath = `/api/personenkontexte/{personenkontextId}`
                .replace(`{${"personenkontextId"}}`, encodeURIComponent(String(personenkontextId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonenkontextBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonenkontexteApi - functional programming interface
 * @export
 */
export const PersonenkontexteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonenkontexteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerDeletePersonenkontextById(personenkontextId, deleteRevisionBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonendatensatzResponseAutomapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerFindPersonenkontextById(personenkontextId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonendatensatzResponseAutomapper>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerFindPersonenkontexte(offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {RollenSystemRecht} systemRecht 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemrechtResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerHatSystemRecht(personId, systemRecht, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {UpdatePersonenkontextBodyParams} updatePersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, updatePersonenkontextBodyParams: UpdatePersonenkontextBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonenkontextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.personenkontextControllerUpdatePersonenkontextWithId(personenkontextId, updatePersonenkontextBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonenkontexteApi - factory interface
 * @export
 */
export const PersonenkontexteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonenkontexteApiFp(configuration)
    return {
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.personenkontextControllerDeletePersonenkontextById(personenkontextId, deleteRevisionBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: any): AxiosPromise<PersonendatensatzResponseAutomapper> {
            return localVarFp.personenkontextControllerFindPersonenkontextById(personenkontextId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] The offset of the paginated list.
         * @param {number} [limit] The requested limit for the page size.
         * @param {string} [referrer] 
         * @param {Rolle} [rolle] 
         * @param {Personenstatus} [personenstatus] 
         * @param {Sichtfreigabe} [sichtfreigabe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: any): AxiosPromise<Array<PersonendatensatzResponseAutomapper>> {
            return localVarFp.personenkontextControllerFindPersonenkontexte(offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId The id for the account.
         * @param {RollenSystemRecht} systemRecht 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: any): AxiosPromise<SystemrechtResponse> {
            return localVarFp.personenkontextControllerHatSystemRecht(personId, systemRecht, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personenkontextId The id for the personenkontext.
         * @param {UpdatePersonenkontextBodyParams} updatePersonenkontextBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, updatePersonenkontextBodyParams: UpdatePersonenkontextBodyParams, options?: any): AxiosPromise<PersonenkontextResponse> {
            return localVarFp.personenkontextControllerUpdatePersonenkontextWithId(personenkontextId, updatePersonenkontextBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonenkontexteApi - interface
 * @export
 * @interface PersonenkontexteApi
 */
export interface PersonenkontexteApiInterface {
    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: AxiosRequestConfig): AxiosPromise<PersonendatensatzResponseAutomapper>;

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig): AxiosPromise<Array<PersonendatensatzResponseAutomapper>>;

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {RollenSystemRecht} systemRecht 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: AxiosRequestConfig): AxiosPromise<SystemrechtResponse>;

    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {UpdatePersonenkontextBodyParams} updatePersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApiInterface
     */
    personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, updatePersonenkontextBodyParams: UpdatePersonenkontextBodyParams, options?: AxiosRequestConfig): AxiosPromise<PersonenkontextResponse>;

}

/**
 * PersonenkontexteApi - object-oriented interface
 * @export
 * @class PersonenkontexteApi
 * @extends {BaseAPI}
 */
export class PersonenkontexteApi extends BaseAPI implements PersonenkontexteApiInterface {
    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {DeleteRevisionBodyParams} deleteRevisionBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerDeletePersonenkontextById(personenkontextId: string, deleteRevisionBodyParams: DeleteRevisionBodyParams, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerDeletePersonenkontextById(personenkontextId, deleteRevisionBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerFindPersonenkontextById(personenkontextId: string, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerFindPersonenkontextById(personenkontextId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] The offset of the paginated list.
     * @param {number} [limit] The requested limit for the page size.
     * @param {string} [referrer] 
     * @param {Rolle} [rolle] 
     * @param {Personenstatus} [personenstatus] 
     * @param {Sichtfreigabe} [sichtfreigabe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerFindPersonenkontexte(offset?: number, limit?: number, referrer?: string, rolle?: Rolle, personenstatus?: Personenstatus, sichtfreigabe?: Sichtfreigabe, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerFindPersonenkontexte(offset, limit, referrer, rolle, personenstatus, sichtfreigabe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId The id for the account.
     * @param {RollenSystemRecht} systemRecht 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerHatSystemRecht(personId: string, systemRecht: RollenSystemRecht, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerHatSystemRecht(personId, systemRecht, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personenkontextId The id for the personenkontext.
     * @param {UpdatePersonenkontextBodyParams} updatePersonenkontextBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonenkontexteApi
     */
    public personenkontextControllerUpdatePersonenkontextWithId(personenkontextId: string, updatePersonenkontextBodyParams: UpdatePersonenkontextBodyParams, options?: AxiosRequestConfig) {
        return PersonenkontexteApiFp(this.configuration).personenkontextControllerUpdatePersonenkontextWithId(personenkontextId, updatePersonenkontextBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProviderApi - axios parameter creator
 * @export
 */
export const ProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all service-providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAllServiceProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provider/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get service-providers available for logged-in user.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAvailableServiceProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/provider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProviderLogo: async (angebotId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'angebotId' is not null or undefined
            assertParamExists('providerControllerGetServiceProviderLogo', 'angebotId', angebotId)
            const localVarPath = `/api/provider/{angebotId}/logo`
                .replace(`{${"angebotId"}}`, encodeURIComponent(String(angebotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all service-providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetAllServiceProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceProviderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetAllServiceProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get service-providers available for logged-in user.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetAvailableServiceProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceProviderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetAvailableServiceProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerControllerGetServiceProviderLogo(angebotId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderApiFp(configuration)
    return {
        /**
         * Get all service-providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAllServiceProviders(options?: any): AxiosPromise<Array<ServiceProviderResponse>> {
            return localVarFp.providerControllerGetAllServiceProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Get service-providers available for logged-in user.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetAvailableServiceProviders(options?: any): AxiosPromise<Array<ServiceProviderResponse>> {
            return localVarFp.providerControllerGetAvailableServiceProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} angebotId The id of the service provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerControllerGetServiceProviderLogo(angebotId: string, options?: any): AxiosPromise<any> {
            return localVarFp.providerControllerGetServiceProviderLogo(angebotId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderApi - interface
 * @export
 * @interface ProviderApi
 */
export interface ProviderApiInterface {
    /**
     * Get all service-providers.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetAllServiceProviders(options?: AxiosRequestConfig): AxiosPromise<Array<ServiceProviderResponse>>;

    /**
     * Get service-providers available for logged-in user.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetAvailableServiceProviders(options?: AxiosRequestConfig): AxiosPromise<Array<ServiceProviderResponse>>;

    /**
     * 
     * @param {string} angebotId The id of the service provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApiInterface
     */
    providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig): AxiosPromise<any>;

}

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI implements ProviderApiInterface {
    /**
     * Get all service-providers.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetAllServiceProviders(options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetAllServiceProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get service-providers available for logged-in user.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetAvailableServiceProviders(options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetAvailableServiceProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} angebotId The id of the service provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public providerControllerGetServiceProviderLogo(angebotId: string, options?: AxiosRequestConfig) {
        return ProviderApiFp(this.configuration).providerControllerGetServiceProviderLogo(angebotId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolleApi - axios parameter creator
 * @export
 */
export const RolleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a service-provider to a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {RolleServiceProviderQueryParams} rolleServiceProviderQueryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddServiceProviderById: async (rolleId: string, rolleServiceProviderQueryParams: RolleServiceProviderQueryParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerAddServiceProviderById', 'rolleId', rolleId)
            // verify required parameter 'rolleServiceProviderQueryParams' is not null or undefined
            assertParamExists('rolleControllerAddServiceProviderById', 'rolleServiceProviderQueryParams', rolleServiceProviderQueryParams)
            const localVarPath = `/api/rolle/{rolleId}/serviceProviders`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolleServiceProviderQueryParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add systemrecht to a rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddSystemRecht: async (rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerAddSystemRecht', 'rolleId', rolleId)
            // verify required parameter 'addSystemrechtBodyParams' is not null or undefined
            assertParamExists('rolleControllerAddSystemRecht', 'addSystemrechtBodyParams', addSystemrechtBodyParams)
            const localVarPath = `/api/rolle/{rolleId}`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addSystemrechtBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerCreateRolle: async (createRolleBodyParams: CreateRolleBodyParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRolleBodyParams' is not null or undefined
            assertParamExists('rolleControllerCreateRolle', 'createRolleBodyParams', createRolleBodyParams)
            const localVarPath = `/api/rolle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRolleBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRolleById: async (rolleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerFindRolleById', 'rolleId', rolleId)
            const localVarPath = `/api/rolle/{rolleId}`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rollen.
         * @summary 
         * @param {string} [searchStr] The name for the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRollen: async (searchStr?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rolle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (searchStr !== undefined) {
                localVarQueryParameter['searchStr'] = searchStr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get service-providers for a rolle by its id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerGetRolleServiceProviderIds: async (rolleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerGetRolleServiceProviderIds', 'rolleId', rolleId)
            const localVarPath = `/api/rolle/{rolleId}/serviceProviders`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a service-provider from a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {string} serviceProviderId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerRemoveServiceProviderById: async (rolleId: string, serviceProviderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolleId' is not null or undefined
            assertParamExists('rolleControllerRemoveServiceProviderById', 'rolleId', rolleId)
            // verify required parameter 'serviceProviderId' is not null or undefined
            assertParamExists('rolleControllerRemoveServiceProviderById', 'serviceProviderId', serviceProviderId)
            const localVarPath = `/api/rolle/{rolleId}/serviceProviders`
                .replace(`{${"rolleId"}}`, encodeURIComponent(String(rolleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (serviceProviderId !== undefined) {
                localVarQueryParameter['serviceProviderId'] = serviceProviderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolleApi - functional programming interface
 * @export
 */
export const RolleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolleApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a service-provider to a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {RolleServiceProviderQueryParams} rolleServiceProviderQueryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderQueryParams: RolleServiceProviderQueryParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerAddServiceProviderById(rolleId, rolleServiceProviderQueryParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add systemrecht to a rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerAddSystemRecht(rolleId, addSystemrechtBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerCreateRolle(createRolleBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerFindRolleById(rolleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleWithServiceProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerFindRolleById(rolleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rollen.
         * @summary 
         * @param {string} [searchStr] The name for the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerFindRollen(searchStr?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RolleWithServiceProvidersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerFindRollen(searchStr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get service-providers for a rolle by its id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolleServiceProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerGetRolleServiceProviderIds(rolleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a service-provider from a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {string} serviceProviderId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolleControllerRemoveServiceProviderById(rolleId, serviceProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolleApi - factory interface
 * @export
 */
export const RolleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolleApiFp(configuration)
    return {
        /**
         * Add a service-provider to a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {RolleServiceProviderQueryParams} rolleServiceProviderQueryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderQueryParams: RolleServiceProviderQueryParams, options?: any): AxiosPromise<ServiceProviderResponse> {
            return localVarFp.rolleControllerAddServiceProviderById(rolleId, rolleServiceProviderQueryParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Add systemrecht to a rolle.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.rolleControllerAddSystemRecht(rolleId, addSystemrechtBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new rolle.
         * @summary 
         * @param {CreateRolleBodyParams} createRolleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: any): AxiosPromise<RolleResponse> {
            return localVarFp.rolleControllerCreateRolle(createRolleBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Get rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRolleById(rolleId: string, options?: any): AxiosPromise<RolleWithServiceProvidersResponse> {
            return localVarFp.rolleControllerFindRolleById(rolleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rollen.
         * @summary 
         * @param {string} [searchStr] The name for the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerFindRollen(searchStr?: string, options?: any): AxiosPromise<Array<RolleWithServiceProvidersResponse>> {
            return localVarFp.rolleControllerFindRollen(searchStr, options).then((request) => request(axios, basePath));
        },
        /**
         * Get service-providers for a rolle by its id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: any): AxiosPromise<RolleServiceProviderResponse> {
            return localVarFp.rolleControllerGetRolleServiceProviderIds(rolleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a service-provider from a rolle by id.
         * @summary 
         * @param {string} rolleId The id for the rolle.
         * @param {string} serviceProviderId The id for the rolle.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolleControllerRemoveServiceProviderById(rolleId, serviceProviderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolleApi - interface
 * @export
 * @interface RolleApi
 */
export interface RolleApiInterface {
    /**
     * Add a service-provider to a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {RolleServiceProviderQueryParams} rolleServiceProviderQueryParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderQueryParams: RolleServiceProviderQueryParams, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderResponse>;

    /**
     * Add systemrecht to a rolle.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Create a new rolle.
     * @summary 
     * @param {CreateRolleBodyParams} createRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig): AxiosPromise<RolleResponse>;

    /**
     * Get rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerFindRolleById(rolleId: string, options?: AxiosRequestConfig): AxiosPromise<RolleWithServiceProvidersResponse>;

    /**
     * List all rollen.
     * @summary 
     * @param {string} [searchStr] The name for the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerFindRollen(searchStr?: string, options?: AxiosRequestConfig): AxiosPromise<Array<RolleWithServiceProvidersResponse>>;

    /**
     * Get service-providers for a rolle by its id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: AxiosRequestConfig): AxiosPromise<RolleServiceProviderResponse>;

    /**
     * Remove a service-provider from a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {string} serviceProviderId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApiInterface
     */
    rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * RolleApi - object-oriented interface
 * @export
 * @class RolleApi
 * @extends {BaseAPI}
 */
export class RolleApi extends BaseAPI implements RolleApiInterface {
    /**
     * Add a service-provider to a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {RolleServiceProviderQueryParams} rolleServiceProviderQueryParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerAddServiceProviderById(rolleId: string, rolleServiceProviderQueryParams: RolleServiceProviderQueryParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerAddServiceProviderById(rolleId, rolleServiceProviderQueryParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add systemrecht to a rolle.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {AddSystemrechtBodyParams} addSystemrechtBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerAddSystemRecht(rolleId: string, addSystemrechtBodyParams: AddSystemrechtBodyParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerAddSystemRecht(rolleId, addSystemrechtBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new rolle.
     * @summary 
     * @param {CreateRolleBodyParams} createRolleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerCreateRolle(createRolleBodyParams: CreateRolleBodyParams, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerCreateRolle(createRolleBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerFindRolleById(rolleId: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerFindRolleById(rolleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rollen.
     * @summary 
     * @param {string} [searchStr] The name for the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerFindRollen(searchStr?: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerFindRollen(searchStr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get service-providers for a rolle by its id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerGetRolleServiceProviderIds(rolleId: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerGetRolleServiceProviderIds(rolleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a service-provider from a rolle by id.
     * @summary 
     * @param {string} rolleId The id for the rolle.
     * @param {string} serviceProviderId The id for the rolle.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolleApi
     */
    public rolleControllerRemoveServiceProviderById(rolleId: string, serviceProviderId: string, options?: AxiosRequestConfig) {
        return RolleApiFp(this.configuration).rolleControllerRemoveServiceProviderById(rolleId, serviceProviderId, options).then((request) => request(this.axios, this.basePath));
    }
}


